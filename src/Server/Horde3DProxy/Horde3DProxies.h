// *************************************************************************************************
// Horde3D Visual Debugger
//
// Axel Habermaier
// Bachelor Thesis, University of Augsburg, 2008/2009
// *************************************************************************************************
//
// This file was generated by the Code Generator tool on 17.5.2009 12:05:12. 
// All modifications made in this file will get lost when the code is regenerated by the tool.
// *************************************************************************************************

#define DLL extern "C" __declspec(dllexport)
#define WIN32_LEAN_AND_MEAN

#include <Windows.h>

// ********************* Horde3D Header File ******************************//
// *************************************************************************************************
//
// Horde3D
//   Next-Generation Graphics Engine
// --------------------------------------
// Copyright (C) 2006-2009 Nicolas Schulz
//
//
// This library is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either
// version 2.1 of the License, or (at your option) any later version.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with this library; if not, write to the Free Software
// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
//
// *************************************************************************************************

/*	Title: Horde3D API */

#pragma once

#ifndef DLL
#	if defined( WIN32 ) || defined( _WINDOWS )
#		define DLL extern "C" __declspec( dllimport )
#	else
#		define DLL extern "C"
#	endif
#endif


/*	Topic: Conventions
		Some conventions for the API.
	
	Horde3D uses a right-handed coordinate system, where y is the up-axis and the positive z-axis is
	pointing out of the screen. The rotations are specified in degrees and rotation direction is
	counter-clockwise when looking down the axis from the the positive end towards the origin. View
	vectors like the camera or light direction are always pointing along the negative z-axis when no
	transformation is applied. Matrices in Horde are stored in a column-major memory layout.
*/


// *************************************************************************************************
// Core Library
// *************************************************************************************************

/* Group: Typedefs and constants */

/*	Constants: Typedefs
	ResHandle   - handle to resource (int)
	NodeHandle  - handle to scene node (int)
*/
typedef int ResHandle;
typedef int NodeHandle;


/*	Constants: Predefined constants
	RootNode  - Scene root node handle
*/
const NodeHandle RootNode = 1;


/* Group: Enumerations */
struct EngineOptions
{
	/*	Enum: EngineOptions
			The available engine option parameters.
		
		MaxLogLevel         - Defines the maximum log level; only messages which are smaller or equal to this value
		                      (hence more important) are published in the message queue. (Default: 4)
		MaxNumMessages      - Defines the maximum number of messages that can be stored in the message queue (Default: 512)
		TrilinearFiltering  - Enables or disables trilinear filtering for textures. (Values: 0, 1; Default: 1)
		MaxAnisotropy       - Sets the maximum quality for anisotropic filtering. (Values: 1, 2, 4, 8; Default: 1)
		TexCompression      - Enables or disables texture compression; only affects textures that are
		                      loaded after setting the option. (Values: 0, 1; Default: 0)
		LoadTextures        - Enables or disables loading of texture images; option can be used to
		                      minimize loading times for testing. (Values: 0, 1; Default: 1)
		FastAnimation       - Disables or enables inter-frame interpolation for animations. (Values: 0, 1; Default: 1)
		ShadowMapSize       - Sets the size of the shadow map buffer (Values: 128, 256, 512, 1024, 2048; Default: 1024)
		SampleCount         - Maximum number of samples used for multisampled render targets; only affects pipelines
		                      that are loaded after setting the option. (Values: 0, 2, 4, 8, 16; Default: 0)
		WireframeMode       - Enables or disables wireframe rendering
		DebugViewMode       - Enables or disables debug view where geometry is rendered in wireframe without shaders and
		                      lights are visualized using their screen space bounding box. (Values: 0, 1; Default: 0)
		DumpFailedShaders   - Enables or disables storing of shader code that failed to compile in a text file; this can be
		                      useful in combination with the line numbers given back by the shader compiler. (Values: 0, 1; Default: 0)
	*/
	enum List
	{
		MaxLogLevel = 1,
		MaxNumMessages,
		TrilinearFiltering,
		MaxAnisotropy,
		TexCompression,
		LoadTextures,
		FastAnimation,
		ShadowMapSize,
		SampleCount,
		WireframeMode,
		DebugViewMode,
		DumpFailedShaders
	};
};

struct EngineStats
{
	/*	Enum: EngineStats
			The available engine statistic parameters.
		
		TriCount        - Number of triangles that were pushed to the renderer
		BatchCount      - Number of batches (draw calls)
		LightPassCount  - Number of lighting passes
	*/
	enum List
	{
		TriCount = 100,
		BatchCount,
		LightPassCount
	};
};

struct ResourceTypes
{
	/*	Enum: ResourceTypes
			The available resource types.
		
		Undefined       - An undefined resource, returned by getResourceType in case of error
		SceneGraph      - Scene graph subtree stored in XML format
		Geometry        - Geometrical data containing bones, vertices and triangles
		Animation       - Animation data
		Material        - Material script
		Code            - Text block containing shader source code
		Shader          - Shader program
		Texture         - Texture map
		ParticleEffect  - Particle configuration
		Pipeline        - Rendering pipeline
	*/
	enum List
	{
		Undefined = 0,
		SceneGraph,
		Geometry,
		Animation,
		Material,
		Code,
		Shader,
		Texture,
		ParticleEffect,
		Pipeline
	};
};

struct ResourceFlags
{
	/*	Enum: ResourceFlags
			The available flags used when adding a resource.
			
		NoQuery           - Excludes resource from being listed by queryUnloadedResource function.
		NoTexCompression  - Disables texture compression for Texture resource.
		NoTexMipmaps      - Disables generation of mipmaps for Texture resources.
	*/
	enum Flags
	{
		NoQuery = 1,
		NoTexCompression = 2,
		NoTexMipmaps = 4
	};
};

struct GeometryResParams
{
	/*	Enum: GeometryResParams
			The available Geometry resource parameters.	  
		
		VertexCount  - Number of vertices; valid for getResourceParami
		IndexCount   - Number of triangle indices; valid for getResourceParami
		VertexData   - Vertex positon data (pointer to float); valid for getResourceData
		IndexData    - Triangle indices (pointer to uint); valid for getResourceData
	 */
	enum List
	{
		VertexCount = 200,
		IndexCount,
		VertexData,
		IndexData
	};
};

struct AnimationResParams
{
	/*	Enum: AnimationResParams
			The available Animation resource parameters.

		FrameCount  - Number of animation frames; valid for getResourceParami
	*/
	enum List
	{
		FrameCount = 300
	};
};

struct MaterialResParams
{
	/*	Enum: MaterialResParams
			The available Material resource parameters.

		Class   - Hierarchical class name (Default: empty string); valid for get-/setResourceParamstr
		Link    - Link to other material resource; valid for get-/setResourceParami
		Shader  - Shader resource used for rendering; valid for get-/setResourceParami
	 */
	enum List
	{
		Class = 400,
		Link,
		Shader
	};	
};

struct TextureResParams
{
	/*	Enum: TextureResParams
			The available Texture resource parameters.

		PixelData  - Image pixel data (pointer to unsigned char); valid for updateResourceData for 2D Textures
		TexType    - Texture type (2D or Cube); valid for getResourceParami
		TexFormat  - Pixel format; valid for getResourceParami
		Width      - Image width in pixels; valid for getResourceParami
		Height     - Image height in pixels; valid for getResourceParami
	 */
	enum List
	{
		PixelData = 700,
		TexType,
		TexFormat,
		Width,
		Height
	};
};

struct ParticleEffectResParams
{
	/*	Enum: ParticleEffectResParams
			The available ParticleEffect resource parameters.

		LifeMin         - Minimum value for selecting random life time; valid for get-/setResourceParamf
		LifeMax	        - Maximum value for selecting random life time; valid for get-/setResourceParamf
		MoveVelMin      - Minimum value for selecting random initial value of velocity defining 
		                  how many units per second particle is moving; valid for get-/setResourceParamf 
		MoveVelMax      - Maximum value for selecting random initial value of velocity defining 
		                   how many units per second particle is moving; valid for get-/setResourceParamf
		MoveVelEndRate  - Percentage of the initial translation velocity value when particle is dying;
		                  valid for get-/setResourceParamf
		RotVelMin       - Minimum value for selecting random initial value of velocity defining 
		                  how many degrees per second particle is rotating; valid for get-/setResourceParamf
		RotVelMax       - Maximum value for selecting random initial value of velocity defining 
		                   how many degrees per second particle is rotating; valid for get-/setResourceParamf
		RotVelEndRate   - Percentage of the initial rotation velocity value when particle is dying;		
		                  valid for get-/setResourceParamf
		SizeVelMin      - Minimum value for selecting random initial size value; 
		                  valid for get-/setResourceParamf
		SizeVelMax      - Maximum value for selecting random initial size value; 
		                  valid for get-/setResourceParamf					      
		SizeVelEndRate  - Percentage of the initial size value when particle is dying;
		                  valid for get-/setResourceParamf					      
		Col_R_Min       - Minimum value for selecting random initial red color value;					     
		                  valid for get-/setResourceParamf					      
		Col_R_Max       - Maximum value for selecting random initial red color value;					      
		                  valid for get-/setResourceParamf					      
		Col_R_EndRate   - Percentage of the initial red value when particle is dying;	   
		                  valid for get-/setResourceParamf					      
		Col_G_Min       - Minimum value for selecting random initial green color value;
		                  valid for get-/setResourceParamf					      
		Col_G_Max       - Maximum value for selecting random initial green color value;
		                  valid for get-/setResourceParamf					      
		Col_G_EndRate   - Percentage of the initial green value when particle is dying;
		                  valid for get-/setResourceParamf					      
		Col_B_Min       - Minimum value for selecting random initial blue color value;
		                  valid for get-/setResourceParamf					      
		Col_B_Max       - Maximum value for selecting random initial blue color value;
		                  valid for get-/setResourceParamf					      
		Col_B_EndRate   - Percentage of the initial blue value when particle is dying;
		                  valid for get-/setResourceParamf					      
		Col_A_Min       - Minimum value for selecting random initial alpha color value;
		                  valid for get-/setResourceParamf					      
		Col_A_Max       - Maximum value for selecting random initial alpha color value;
		                  valid for get-/setResourceParamf					      
		Col_A_EndRate   - Percentage of the initial alpha value when particle is dying;
		                  valid for get-/setResourceParamf					      
	*/
	enum List
	{
		LifeMin = 900,
		LifeMax,
		MoveVelMin,
		MoveVelMax,
		MoveVelEndRate,
		RotVelMin,
		RotVelMax,
		RotVelEndRate,
		SizeMin,
		SizeMax,
		SizeEndRate,
		Col_R_Min,
		Col_R_Max,
		Col_R_EndRate,
		Col_G_Min,
		Col_G_Max,
		Col_G_EndRate,
		Col_B_Min,
		Col_B_Max,
		Col_B_EndRate,
		Col_A_Min,
		Col_A_Max,
		Col_A_EndRate
	};
};

struct SceneNodeTypes
{
	/*	Enum: SceneNodeTypes
			The available scene node types.
		
		Undefined  - An undefined node type, returned by getNodeType in case of error
		Group      - Group of different scene nodes
		Model      - 3D model with optional skeleton
		Mesh       - Subgroup of a model with triangles of one material
		Joint      - Joint for skeletal animation
		Light      - Light source
		Camera     - Camera giving view on scene
		Emitter    - Particle system emitter
	*/
	enum List
	{
		Undefined = 0,
		Group,
		Model,
		Mesh,
		Joint,
		Light,
		Camera,
		Emitter
	};
};

struct SceneNodeParams
{
	/*	Enum: SceneNodeParams
			The available scene node parameters.

		Name              - Name of the scene node [type: string]
		AttachmentString  - Optional application-specific meta data for a node
		                    encapsulated in an 'Attachment' XML string [type: string]
	*/
	enum List
	{
		Name = 1,
		AttachmentString
	};
};


struct ModelNodeParams
{
	/*	Enum: ModelNodeParams
			The available Model node parameters

		GeometryRes       - Geometry resource used for the model [type: ResHandle]
		SoftwareSkinning  - Enables or disables software skinning (default: 0) [type: int]
		LodDist1          - Distance to camera from which on LOD1 is used (default: infinite) [type: float]
		                    (must be a positive value larger than 0.0)
		LodDist2          - Distance to camera from which on LOD2 is used
		                    (may not be smaller than LodDist1) (default: infinite) [type: float]
		LodDist3          - Distance to camera from which on LOD3 is used
		                    (may not be smaller than LodDist2) (default: infinite) [type: float]
		LodDist4          - Distance to camera from which on LOD4 is used
		                    (may not be smaller than LodDist3) (default: infinite) [type: float]
	*/
	enum List
	{
		GeometryRes = 200,
		SoftwareSkinning,
		LodDist1,
		LodDist2,
		LodDist3,
		LodDist4
	};
};

struct MeshNodeParams
{
	/*	Enum: MeshNodeParams
			The available Mesh node parameters.
		
		MaterialRes  - Material resource used for the mesh [type: ResHandle]
		BatchStart   - First triangle index of mesh in Geometry resource of parent Model node [type: int, read-only]
		BatchCount   - Number of triangle indices used for drawing mesh [type: int, read-only]
		VertRStart   - First vertex in Geometry resource of parent Model node [type: int, read-only]
		VertREnd     - Last vertex in Geometry resource of parent Model node [type: int, read-only]
		LodLevel     - LOD level of Mesh; the mesh is only rendered if its LOD level corresponds to
		               the model's current LOD level which is calculated based on the LOD distances (default: 0) [type: int]
	*/
	enum List
	{
		MaterialRes = 300,
		BatchStart,
		BatchCount,
		VertRStart,
		VertREnd,
		LodLevel
	};
};

struct JointNodeParams
{
	/*	Enum: JointNodeParams
			The available Joint node parameters.

		JointIndex  - Index of joint in Geometry resource of parent Model node [type: int, read-only]
	*/
	enum List
	{
		JointIndex = 400
	};
};

struct LightNodeParams
{
	/*	Enum: LightNodeParams
			The available Light node parameters.
		
		MaterialRes         - Material resource used for the light [type: ResHandle]
		Radius              - Radius of influence (default: 100.0) [type: float]
		FOV                 - Field of view (FOV) angle (default: 90.0) [type: float]
		Col_R               - Red component of light diffuse color (default: 1.0) [type: float]
		Col_G               - Green component of light diffuse color (default: 1.0) [type: float]
		Col_B               - Blue component of light diffuse color (default: 1.0) [type: float]
		ShadowMapCount      - Number of shadow maps used for light source (values: 0, 1, 2, 3, 4; default: 0) [type: int]
		ShadowSplitLambda   - Constant determining segmentation of view frustum for Parallel Split Shadow Maps
		                      (default: 0.5) [type: float]
		ShadowMapBias       - Bias value for shadow mapping to reduce shadow acne (default: 0.005) [type: float]
	*/
	enum List
	{
		MaterialRes = 500,
		Radius,
		FOV,
		Col_R,
		Col_G,
		Col_B,
		ShadowMapCount,
		ShadowSplitLambda,
		ShadowMapBias
	};
};

struct CameraNodeParams
{
	/*	Enum: CameraNodeParams
			The available Camera node parameters.
		
		PipelineRes        - Pipeline resource used for rendering [type: ResHandle]
		OutputTex          - 2D Texture resource used as output buffer (can be 0 to use main framebuffer) (default: 0) [type: ResHandle]
		OutputBufferIndex  - Index of the output buffer for stereo rendering (values: 0 for left eye, 1 for right eye) (default: 0) [type: int]
		LeftPlane          - Coordinate of left plane relative to near plane center (default: -0.055228457) [type: float]
		RightPlane         - Coordinate of right plane relative to near plane center (default: 0.055228457) [type: float]
		BottomPlane        - Coordinate of bottom plane relative to near plane center (default: -0.041421354f) [type: float]
		TopPlane           - Coordinate of top plane relative to near plane center (default: 0.041421354f) [type: float]
		NearPlane          - Distance of near clipping plane (default: 0.1) [type: float]
		FarPlane           - Distance of far clipping plane (default: 1000) [type: float]
		Orthographic       - Flag for setting up an orthographic frustum instead of a perspective one (default: 0) [type:int]
		OcclusionCulling   - Flag for enabling occlusion culling (default: 0) [type:int]
	*/
	enum List
	{
		PipelineRes = 600,
		OutputTex,
		OutputBufferIndex,
		LeftPlane,
		RightPlane,
		BottomPlane,
		TopPlane,
		NearPlane,
		FarPlane,
		Orthographic,
		OcclusionCulling
	};
};

struct EmitterNodeParams
{
	/*	Enum: EmitterNodeParams
			The available Emitter node parameters.
		
		MaterialRes        - Material resource used for rendering [type: ResHandle]
		ParticleEffectRes  - ParticleEffect resource which configures particle properties [type: ResHandle]
		MaxCount           - Maximal number of particles living at the same time [type: int]
		RespawnCount       - Number of times a single particle is recreated after dying (-1 for infinite) [type: int]
		Delay              - Time in seconds before emitter begins creating particles (default: 0.0) [type: float]
		EmissionRate       - Maximal number of particles to be created per second (default: 0.0) [type: float]
		SpreadAngle        - Angle of cone for random emission direction (default: 0.0) [type: float]
		ForceX             - X-component of force vector applied to particles (default: 0.0) [type: float]
		ForceY             - Y-component of force vector applied to particles (default: 0.0) [type: float]
		ForceZ             - Z-component of force vector applied to particles (default: 0.0) [type: float]
	*/
	enum List
	{
		MaterialRes = 700,
		ParticleEffectRes,
		MaxCount,
		RespawnCount,
		Delay,
		EmissionRate,
		SpreadAngle,
		ForceX,
		ForceY,
		ForceZ
	};
};


namespace Horde3D
{
	/* Group: Basic functions */
	/* 	Function: getVersionString
			Returns the engine version string.
		
		This function returns a pointer to a string containing the current version of Horde3D.
		
		Parameters:
			none
			
		Returns:
			pointer to the version string
	*/
	DLL const char *getVersionString();

	/* 	Function: checkExtension
			Checks if an extension is part of the engine library.
		
		This function checks if a specified extension is contained in the DLL/shared object of the engine.
		
		Parameters:
			extensionName  - name of the extension
			
		Returns:
			true if extension is implemented, otherwise false
	*/
	DLL bool checkExtension( const char *extensionName );
	
	/* 	Function: init
			Initializes the engine.
		
		This function initializes the graphics engine and makes it ready for use. It has to be the
		first call to the engine except for getVersionString. In order to successfully initialize
		the engine the calling application must provide a valid OpenGL context. The function can be
		called several times on different rendering contexts in order to initialize them.
		
		Parameters:
			none
			
		Returns:
			true in case of success, otherwise false
	*/
	DLL	bool init();
	
	/* 	Function: release
			Releases the engine.
		
		This function releases the engine and frees all objects and associated memory. It should be
		called when the application is destroyed.
		
		Parameters:
			none
			
		Returns:
			nothing
	*/
	DLL void release();
	
	/* 	Function: setupViewport
			Sets the location and size of the viewport.
		
		This function sets the location and size of the viewport. It has to be called
		after engine initialization and whenever the size of the rendering context/window
		changes. The resizeBuffers parameter specifies whether render targets with a size
		relative to the viewport dimensions should be resized. This is usually desired
		after engine initialization and when the window is resized but not for just rendering
		to a part of the framebuffer.

		
		Parameters:
			x              - the x-position of the lower left corner of the viewport rectangle
			y              - the y-position of the lower left corner of the viewport rectangle
			width          - the width of the viewport
			height         - the height of the viewport
			resizeBuffers  - specifies whether render targets should be adapted to new size
			
		Returns:
			nothing
	*/
	DLL void setupViewport( int x, int y, int width, int height, bool resizeBuffers );
	
	/* 	Function: render
			Main rendering function.
		
		This is the main function of the engine. It executes all the rendering, animation and other
		tasks. The function can be called several times per frame, for example in order to write to different
		output buffers.
		
		Parameters:
			cameraNode  - camera node used for rendering scene
			
		Returns:
			true in case of success, otherwise false
	*/
	DLL bool render( NodeHandle cameraNode );
	
	/* 	Function: finalizeFrame
			Marker for end of frame.
		
		This function tells the engine that the current frame is finished and that all
		subsequent rendering operations will be for the next frame.
		
		Parameters:
			none
			
		Returns:
			true in case of success, otherwise false
	*/
	DLL bool finalizeFrame();
	
	/* 	Function: clear
			Removes all resources and scene nodes.
		
		This function removes all nodes from the scene graph except the root node and releases all resources.
		
		*Warning: All resource and node IDs are invalid after calling this function*
		
		Parameters:
			none
			
		Returns:
			nothing
	*/
	DLL void clear();


	// --- General functions ---
	/* 	Function: getMessage
			Gets the next message from the message queue.
		
		This function returns the next message string from the message queue and writes additional information
		to the specified variables. If no message is left over in the queue an empty string is returned.
		
		Parameters:
			level  - pointer to variable for storing message level indicating importance (can be NULL)
			time   - pointer to variable for storing time when message was added (can be NULL)
			
		Returns:
			message string or empty string if no message is in queue
	*/
	DLL const char *getMessage( int *level, float *time );
	
	/* 	Function: getOption
			Gets an option parameter of the engine.
		
		This function gets a specified option parameter and returns its value.
		
		Parameters:
			param  - option parameter
			
		Returns:
			current value of the specified option parameter
	*/
	DLL float getOption( EngineOptions::List param );
	
	/* 	Function: setOption
			Sets an option parameter for the engine.
		
		This function sets a specified option parameter to a specified value.
		
		Parameters:
			param  - option parameter
			value  - value of the option parameter
			
		Returns:
			true if the option could be set to the specified value, otherwise false
	*/
	DLL bool setOption( EngineOptions::List param, float value );

	/* 	Function: getStat
			Gets a statistic value of the engine.
		
		This function returns the value of the specified statistic. The reset flag makes it possible
		to reset the statistic value after reading.
		
		Parameters:
			param  - statistic parameter
			reset  - flag specifying whether statistic value should be reset
			
		Returns:
			current value of the specified statistic parameter
	*/
	DLL float getStat( EngineStats::List param, bool reset );
	
	/* 	Function: showOverlay
			Shows an overlay on the screen.
		
		This function displays an overlay with a specified material at a specified position on the screen.
		An overlay is a 2D image that can be used to render 2D GUI elements. The coordinate system
		used has its origin (0, 0) at the top-left corner of the screen and its maximum (1, 1) at
		the bottom-right corner. Texture coordinates are using a system where the coordinates (0, 0)
		correspond to the lower left corner of the image.
		Overlays can have different layers which describe the order in which they are drawn. Overlays with
		smaller layer numbers are drawn before overlays with higher layer numbers.
		Note that the overlays have to be removed manually using the function clearOverlays.
		
		Parameters:
			x_tl, y_tl, u_tl, v_tl  - position and texture coordinates of the top-left corner
			x_bl, y_bl, u_bl, v_bl  - position and texture coordinates of the bottom-left corner
			x_br, y_br, u_br, v_br  - position and texture coordinates of the bottom-right corner
			x_tr, y_tr, u_tr, v_tr  - position and texture coordinates of the top-right corner
			colR, colG, colB, colA  - color of the overlay that is set for the material's shader
			materialRes             - material resource used for rendering
			layer                   - layer index of the overlay (Values: from 0 to 7)
			
		Returns:
			nothing
	*/
	DLL void showOverlay( float x_tl, float y_tl, float u_tl, float v_tl,
	                      float x_bl, float y_bl, float u_bl, float v_bl,
	                      float x_br, float y_br, float u_br, float v_br,
	                      float x_tr, float y_tr, float u_tr, float v_tr,
	                      float colR, float colG, float colB, float colA,
	                      ResHandle materialRes, int layer );

	/* 	Function: clearOverlays
			Removes all overlays.
		
		This function removes all overlays that were added usig showOverlay.
		
		Parameters:
			none
			
		Returns:
			nothing
	*/
	DLL void clearOverlays();


	/* Group: General resource management functions */
	/* 	Function: getResourceType
			Returns the type of a resource.
		
		This function returns the type of a specified resource. If the resource handle is invalid,
		the function returns the resource type 'Unknown'.
		
		Parameters:
			res  - handle to the resource
			
		Returns:
			type of the resource
	*/
	DLL int getResourceType( ResHandle res );

	/* 	Function: getResourceName
			Returns the name of a resource.
		
		This function returns a pointer to the name of a specified resource. If the resource handle
		is invalid, the function returns an empty string.

		*Important Note: The pointer is const and allows only read access to the data. Do never try to modify the
		data of the pointer since that can corrupt the engine's internal states!*
		
		Parameters:
			res  - handle to the resource
			
		Returns:
			name of the resource or empty string in case of failure
	*/
	DLL const char *getResourceName( ResHandle res );
	
	/* 	Function: getNextResource
			Returns the next resource of the specified type.
		
		This function searches the next resource of the specified type and returns its handle.
		The search begins after the specified start handle. If a further resource of the queried type
		does not exist, a zero handle is returned. The function can be used to iterate over all
		resources of a given type by using as start the return value of the previous iteration step.
		The first iteration step should start at 0 and iteration can be ended when the function returns 0.
		
		Parameters:
			type   - type of resource to be searched (ResourceTypes::Undefined for all types)
			start  - resource handle after which the search begins (can be 0 for beginning of resource list)
			
		Returns:
			handle to the found resource or 0 if it does not exist
	*/
	DLL ResHandle getNextResource( int type, ResHandle start );
	
	/* 	Function: findResource
			Finds a resource and returns its handle.
		
		This function searches the resource of the specified type and name and returns its handle. If
		the resource is not available in the resource manager a zero handle is returned.
		
		Parameters:
			type  - type of the resource
			name  - name of the resource
			
		Returns:
			handle to the resource or 0 if not found
	*/
	DLL ResHandle findResource( int type, const char *name );
	
	/* 	Function: addResource
			Adds a resource.
		
		This function tries to add a resource of a specified type and name to the resource manager. If
		a resource of the same type and name is already existing, the handle to the existing resource is returned
		instead of creating a new one and the user reference count of the resource is increased.

		*Note: The name string may not contain a colon character (:)*
		
		Parameters:
			type   - type of the resource
			name   - name of the resource
			flags  - flags used for creating the resource
			
		Returns:
			handle to the resource to be added or 0 in case of failure
	*/
	DLL ResHandle addResource( int type, const char *name, int flags );

	/* 	Function: cloneResource
			Duplicates a resource.
		
		This function duplicates a specified resource. In the cloning process a new resource with the
		specified name is added to the resource manager and filled with the data of the specified source
		resource. If the specified name for the new resource is already in use, the function fails and
		returns 0. If the name string is empty, a unique name for the resource is generated automatically.
		
		*Note: The name string may not contain a colon character (:)*
		
		Parameters:
			sourceRes  - handle to resource to be cloned
			name       - name of new resource (can be empty for auto-naming)
			
		Returns:
			handle to the cloned resource or 0 in case of failure
	*/
	DLL ResHandle cloneResource( ResHandle sourceRes, const char *name );
	
	/* 	Function: removeResource
			Removes a resource.
		
		This function decreases the user reference count of a specified resource. When the user reference
		count is zero and there are no internal references, the resource can be released and removed using
		the API fuction releaseUnusedResources.
		
		Parameters:
			res	- handle to the resource to be removed
			
		Returns:
			the number of references that the application is still holding after removal or -1 in case of an error
	*/
	DLL int removeResource( ResHandle res );
	
	/* 	Function: isResourceLoaded
			Checks if a resource is loaded.
		
		This function checks if the specified resource has been successfully loaded.
		
		Parameters:
			res  - handle to the resource to be checked
			
		Returns:
			true if resource is loaded, otherwise or in case of failure false
	*/
	DLL bool isResourceLoaded( ResHandle res );
	
	/* 	Function: loadResource
			Loads a resource.
		
		This function loads data for a resource that was previously added to the resource manager.
		If data is a NULL-pointer the resource manager is told that the resource doesn't have any data
		(e.g. the corresponding file was not found). In this case, the resource remains in the unloaded state
		but is no more returned when querying unloaded resources. When the specified resource is already loaded,
		the function returns false.
		
		*Important Note: XML-data must be NULL-terminated*
		
		Parameters:
			res   - handle to the resource for which data will be loaded
			data  - pointer to the data to be loaded
			size  - size of the data block
			
		Returns:
			true in case of success, otherwise false
	*/
	DLL bool loadResource( ResHandle res, const char *data, int size );
	
	/* 	Function: unloadResource
			Unloads a resource.
		
		This function unloads a previously loaded resource and restores the default values
		it had before loading. The state is set back to unloaded which makes it possible to load
		the resource again.
		
		Parameters:
			res  - handle to resource to be unloaded
			
		Returns:
			true in case of success, otherwise false
	*/
	DLL bool unloadResource( ResHandle res );


	/* 	Function: getResourceParami
			Gets a property of a resource.
		
		This function returns a specified property of the specified resource.
		The property must be of the type int.
		
		Parameters:
			res    - handle to the resource to be accessed
			param  - parameter to be accessed
			
		Returns:
			value of the parameter
	*/
	DLL int getResourceParami( ResHandle res, int param );

	/* 	Function: setResourceParami
			Sets a property of a resource.
		
		This function sets a specified property of the specified resource to a specified value.
		The property must be of the type int.
		
		Parameters:
			node   - handle to the node to be modified
			param  - parameter to be modified
			value  - new value for the specified parameter
			
		Returns:
			 true in case of success otherwise false
	*/
	DLL bool setResourceParami( ResHandle res, int param, int value );

	/* 	Function: getResourceParamf
			Gets a property of a resource.
		
		This function returns a specified property of the specified resource.
		The property must be of the type float.
		
		Parameters:
			res    - handle to the resource to be accessed
			param  - parameter to be accessed
			
		Returns:
			value of the parameter
	*/
	DLL float getResourceParamf( ResHandle res, int param );

	/* 	Function: setResourceParamf
			Sets a property of a resource.
		
		This function sets a specified property of the specified resource to a specified value.
		The property must be of the type float.
		
		Parameters:
			node   - handle to the node to be modified
			param  - parameter to be modified
			value  - new value for the specified parameter
			
		Returns:
			true in case of success otherwise false
	*/
	DLL bool setResourceParamf( ResHandle res, int param, float value );

	/* 	Function: getResourceParamstr
			Gets a property of a resource.
		
		This function returns a specified property of the specified resource.
		The property must be of the type string (const char *).

		*Important Note: The pointer is const and allows only read access to the data. Do never try to modify the
		data of the pointer since that can corrupt the engine's internal states!*
		
		Parameters:
			res    - handle to the resource to be accessed
			param  - parameter to be accessed
			
		Returns:
			value of the property or empty string if no such property exists
	*/
	DLL const char *getResourceParamstr( ResHandle res, int param );

	/* 	Function: setResourceParamstr
			Sets a property of a resource.
		
		This function sets a specified property of the specified resource to a specified value.
		The property must be of the type string (const char *).
		
		Parameters:
			node   - handle to the node to be modified
			param  - parameter to be modified
			value  - new value for the specified parameter
			
		Returns:
			true in case of success otherwise false
	*/
	DLL bool setResourceParamstr( ResHandle res, int param, const char *value );

	/* 	Function: getResourceData
			Gives access to resource data.
		
		This function returns a pointer to the specified data of a specified resource. For information on the
		format (uint, float, ..) of the pointer see the ResourceData description.

		*Important Note: The pointer is const and allows only read access to the data. Do never try to modify the
		data of the pointer since that can corrupt the engine's internal states!*
		
		Parameters:
			res    - handle to the resource to be accessed
			param  - parameter indicating data of the resource that will be accessed
			
		Returns:
			pointer to the specified resource data if it is available, otherwise NULL-pointer
	*/
	DLL const void *getResourceData( ResHandle res, int param );
	
	/* 	Function: updateResourceData
			Updates the data of a resource.
		
		This function updates the content of a resource that was successfully loaded before. The new data must
		have exactly the same data layout as the data that was loaded.

		Notes on available ResourceData parameters:
		- TextureResParams::PixelData
			Sets the image data of a 2D Texture resource. The data pointer must point to a memory block that contains
			the pixels of the image. Each pixel needs to have 32 bit color data in BGRA format and the dimensions
			of the image (width, height) must be exactly the same as the dimensions of the image that was
			originally loaded for the resource. The first element in the data array corresponds to the lower left
			corner of the image and subsequent elements progress from left to right in the image.
		
		Parameters:
			res    - handle to the resource for which the data is modified
			param  - data structure which will be updated
			data   - pointer to the new data
			size   - size of the new data block
			
		Returns:
			true in case of success, otherwise false
	*/
	DLL bool updateResourceData( ResHandle res, int param, const void *data, int size );
	
	/* 	Function: queryUnloadedResource
			Returns handle to an unloaded resource.
		
		This function looks for a resource that is not yet loaded and returns its handle.
		If there are no unloaded resources or the zero based index specified is greater than the number
		of the currently unloaded resources, 0 is returned.
		
		Parameters:
			index  - index of unloaded resource within the internal list of unloaded resources (starting with 0) 
			
		Returns:
			handle to an unloaded resource or 0
	*/
	DLL ResHandle queryUnloadedResource( int index );
	
	/* 	Function: releaseUnusedResources
			Frees resources that are no longer used.
		
		This function releases resources that are no longer used. Unused resources were either told
		to be released by the user calling removeResource or are no more referenced by any other
		engine objects.
		
		Parameters:
			none
			
		Returns:
			nothing
	*/
	DLL void releaseUnusedResources();


	/* Group: Specific resource management functions */
	/* 	Function: createTexture2D
			Adds a 2D Texture resource.
		
		This function tries to create and add a 2D Texture resource with the specified name to the resource
		manager. If a Texture resource with the same name is already existing, the function fails. The
		texture is initialized with the specified dimensions and the resource is declared as loaded. This
		function is especially useful to create dynamic textures (e.g. for displaying videos) or output buffers
		for render-to-texture.

		*Note: The name string may not contain a colon character (:)*
		
		Parameters:
			name        - name of the resource
			flags       - flags used for creating the resource
			width       - width of the texture image
			height      - height of the texture image
			renderable  - flag indicating whether the texture can be used as an output buffer for a Camera node
			
		Returns:
			handle to the created resource or 0 in case of failure
	*/
	DLL ResHandle createTexture2D( const char *name, int flags, int width, int height, bool renderable );
	
	/* 	Function: setShaderPreambles
			Sets preambles of all Shader resources.
		
		This function defines a header that is inserted at the beginning of all shaders. The preamble
		is used when a shader is compiled, so changing it will not affect any shaders that are already
		compiled. The preamble is useful for setting platform-specific defines that can be employed for
		creating several shader code paths, e.g. for supporting different hardware capabilities.
		
		Parameters:
			vertPreamble  - preamble text of vertex shaders (default: empty string)
			fragPreamble  - preamble text of fragment shaders (default: empty string)
			
		Returns:
			nothing
	*/
	DLL void setShaderPreambles( const char *vertPreamble, const char *fragPreamble );
	
	/* 	Function: setMaterialUniform
			Sets a shader uniform of a Material resource.
		
		This function sets the specified shader uniform of the specified material to the specified values.
		
		Parameters:
			materialRes  - handle to the Material resource to be accessed
			name         - name of the uniform as defined in Material resource
			a, b, c, d   - values of the four components
			
		Returns:
			true in case of success, otherwise false
	*/
	DLL bool setMaterialUniform( ResHandle materialRes, const char *name, float a, float b, float c, float d );

	/* 	Function: setPipelineStageActivation
			Sets the activation state of a pipeline stage.
		
		This function enables or disables a specified stage of the specified pipeline resource.
		
		Parameters:
			pipelineRes  - handle to the Pipeline resource to be accessed
			stageName    - name of the stage to be modified
			enabled      - flag indicating whether the stage shall be enabled or disabled
			
		Returns:
			true in case of success, otherwise false
	*/
	DLL bool setPipelineStageActivation( ResHandle pipelineRes, const char *stageName, bool enabled );
	
	/* 	Function: getPipelineRenderTargetData
			Reads the pixel data of a pipeline render target buffer.
		
		This function reads the pixels of the specified buffer of the specified render target from the specified
		pipeline resource and stores it in the specified float array. To calculate the size required for the array this
		function can be called with a NULL pointer for dataBuffer and pointers to variables where the width,
		height and number of (color) components (e.g. 4 for RGBA or 1 for depth) will be stored.
		The function is not intended to be used for real-time scene rendering but rather as a tool for debugging.
		For more information about the render buffers please refer to the Pipeline documentation.
		
		Parameters:
			pipelineRes  - handle to pipeline resource
			targetName   - unique name of render target to access
			bufIndex     - index of buffer to be accessed
			width        - pointer to variable where the width of the buffer will be stored (can be NULL)
			height       - pointer to variable where the height of the buffer will be stored (can be NULL)
			compCount    - pointer to variable where the number of components will be stored (can be NULL)
			dataBuffer   - pointer to float array where the pixel data will be stored (can be NULL)
			bufferSize   - size of dataBuffer array in bytes
			
		Returns:
			true in case of success, otherwise false
	*/
	DLL bool getPipelineRenderTargetData( ResHandle pipelineRes, const char *targetName,
	                                      int bufIndex, int *width, int *height, int *compCount,
	                                      float *dataBuffer, int bufferSize );


	/* Group: General scene graph functions */
	/* 	Function: getNodeType
			Returns the type of a scene node.
		
		This function returns the type of a specified scene node. If the node handle is invalid,
		the function returns the node type 'Unknown'.
		
		Parameters:
			node  - handle to the scene node
			
		Returns:
			type of the scene node
	*/
	DLL int getNodeType( NodeHandle node );
		
	/* 	Function: getNodeParent
			Returns the parent of a scene node.
		
		This function returns the handle to the parent node of a specified scene node. If the specified
		node handle is invalid or the root node, 0 is returned.
		
		Parameters:
			node  - handle to the scene node
			
		Returns:
			handle to parent node or 0 in case of failure
	*/
	DLL NodeHandle getNodeParent( NodeHandle node );


	/* 	Function: setNodeParent
			Relocates a node in the scene graph.
		
		This function relocates a scene node. It detaches the node from its current parent and attaches
		it to the specified new parent node. If the attachment to the new parent is not possible, the
		function returns false. Relocation is not possible for the RootNode.
		
		Parameters:
			node    - handle to the scene node to be relocated
			parent  - handle to the new parent node
			
		Returns:
			true in case of success, otherwise false
	*/
	DLL bool setNodeParent( NodeHandle node, NodeHandle parent );
	
	/* 	Function: getNodeChild
			Returns the handle to a child node.
		
		This function looks for the n-th (index) child node of a specified node and returns its handle. If the child
		doesn't exist, the function returns 0.
		
		Parameters:
			node   - handle to the parent node
			index  - index of the child node
			
		Returns:
			handle to the child node or 0 if child doesn't exist
	*/
	DLL NodeHandle getNodeChild( NodeHandle node, int index );


	
	/* 	Function: addNodes
			Adds nodes from a SceneGraph resource to the scene.
		
		This function creates several new nodes as described in a SceneGraph resource and
		attaches them to a specified parent node. If an invalid scenegraph resource is specified
		or the scenegraph resource is unloaded, the function returns 0.
		
		Parameters:
			parent         - handle to parent node to which the root of the new nodes will be attached
			sceneGraphRes  - handle to loaded SceneGraph resource
			
		Returns:
			handle to the root of the created nodes or 0 in case of failure
	*/
	DLL NodeHandle addNodes( NodeHandle parent, ResHandle sceneGraphRes );
	
	/* 	Function: removeNode
			Removes a node from the scene.
		
		This function removes the specified node and all of it's children from the scene.
		
		Parameters:
			node  - handle to the node to be removed
			
		Returns:
			true in case of success otherwise false
	*/
	DLL bool removeNode( NodeHandle node );
	
	/* 	Function: setNodeActivation
			Sets the activation (visibility) state of a node.
		
		This function sets the activation state of the specified node to active or inactive. Inactive
		nodes with all their children are excluded from rendering.
		
		Parameters:
			node    - handle to the node to be modified
			active  - boolean value indicating whether node shall be active or inactive
			
		Returns:
			true in case of success otherwise false
	*/
	DLL bool setNodeActivation( NodeHandle node, bool active );

	/* 	Function: checkNodeTransformFlag
			Checks if a scene node has been transformed by the engine.
		
		This function checks if a scene node has been transformed by the engine since the last
		time the transformation flag was reset. Therefore, it stores a flag that is set to true when a
		setTransformation function is called explicitely by the application or when the node transformation
		has been updated by the animation system. The function also makes it possible to reset the
		transformation flag.
		
		Parameters:
			node   - handle to the node to be accessed
			reset  - flag indicating whether transformation flag shall be reset
			
		Returns:
			true if node has been transformed, otherwise false
	*/
	DLL bool checkNodeTransformFlag( NodeHandle node, bool reset );
	
	/* 	Function: getNodeTransform
			Gets the relative transformation of a node.
		
		This function gets the translation, rotation and scale of a specified scene node object. The
		coordinates are in local space and contain the transformation of the node relative to its parent.
		
		Parameters:
			node        - handle to the node which will be accessed
			tx, ty, tz  - pointers to variables where translation of the node will be stored (can be NULL)
			rx, ry, rz  - pointers to variables where rotation of the node in Euler angles
			              will be stored (can be NULL)
			sx, sy, sz  - pointers to variables where scale of the node will be stored (can be NULL)
			
		Returns:
			true in case of success otherwise false
	*/
	DLL bool getNodeTransform( NodeHandle node, float *tx, float *ty, float *tz,
	                           float *rx, float *ry, float *rz, float *sx, float *sy, float *sz );
	
	/* 	Function: setNodeTransform
			Sets the relative transformation of a node.
		
		This function sets the relative translation, rotation and scale of a specified scene node object.
		The coordinates are in local space and contain the transformation of the node relative to its parent.
		
		Parameters:
			node        - handle to the node which will be modified
			tx, ty, tz  - translation of the node
			rx, ry, rz  - rotation of the node in Euler angles
			sx, sy, sz  - scale of the node
			
		Returns:
			true in case of success otherwise false
	*/
	DLL bool setNodeTransform( NodeHandle node, float tx, float ty, float tz,
	                           float rx, float ry, float rz, float sx, float sy, float sz );
	
	/* 	Function: getNodeTransformMatrices
			Returns the transformation matrices of a node.
		
		This function stores a pointer to the relative and absolute transformation matrices
		of the specified node in the specified pointer varaibles.
		
		Parameters:
			node    - handle to the scene node to be accessed
			relMat  - pointer to a variable where the address of the relative transformation matrix will be stored
			          (can be NULL if matrix is not required)
			absMat  - pointer to a variable where the address of the absolute transformation matrix will be stored
			          (can be NULL if matrix is not required)
			
			
		Returns:
			true in case of success otherwise false
	*/
	DLL bool getNodeTransformMatrices( NodeHandle node, const float **relMat, const float **absMat );
	
	/* 	Function: setNodeTransformMatrix
			Sets the relative transformation matrix of a node.
		
		This function sets the relative transformation matrix of the specified scene node. It is basically the
        same as setNodeTransform but takes directly a matrix instead of individual transformation parameters.
		
		Parameters:
			node    - handle to the node which will be modified
			mat4x4  - pointer to a 4x4 matrix in column major order
			
		Returns:
			true in case of success otherwise false
	*/
	DLL bool setNodeTransformMatrix( NodeHandle node, const float *mat4x4 );

	/* 	Function: getNodeParamf
			Gets a property of a scene node.
		
		This function returns a specified property of the specified node.
		The property must be of the type float.
		
		Parameters:
			node   - handle to the node to be accessed
			param  - parameter to be accessed
			
		Returns:
			value of the parameter
	*/
	DLL float getNodeParamf( NodeHandle node, int param );
	
	/* 	Function: setNodeParamf
			Sets a property of a scene node.
		
		This function sets a specified property of the specified node to a specified value.
		The property must be of the type float.
		
		Parameters:
			node   - handle to the node to be modified
			param  - parameter to be modified
			value  - new value for the specified parameter
			
		Returns:
			true in case of success otherwise false
	*/
	DLL bool setNodeParamf( NodeHandle node, int param, float value );

	/* 	Function: getNodeParami
			Gets a property of a scene node.
		
		This function returns a specified property of the specified node.
		The property must be of the type int or ResHandle.
		
		Parameters:
			node   - handle to the node to be accessed
			param  - parameter to be accessed
			
		Returns:
			value of the parameter
	*/
	DLL int getNodeParami( NodeHandle node, int param );
	
	/* 	Function: setNodeParami
			Sets a property of a scene node.
		
		This function sets a specified property of the specified node to a specified value.
		The property must be of the type int or ResHandle.
		
		Parameters:
			node   - handle to the node to be modified
			param  - parameter to be modified
			value  - new value for the specified parameter
			
		Returns:
			true in case of success otherwise false
	*/
	DLL bool setNodeParami( NodeHandle node, int param, int value );

	/* 	Function: getNodeParamstr
			Gets a property of a scene node.
		
		This function returns a specified property of the specified node.
		The property must be of the type string (const char *).

		*Important Note: The pointer is const and allows only read access to the data. Do never try to modify the
        data of the pointer since that can corrupt the engine's internal states!*
		
		Parameters:
			node   - handle to the node to be accessed
			param  - parameter to be accessed
			
		Returns:
			value of the property or empty string if no such property exists
	*/
	DLL const char *getNodeParamstr( NodeHandle node, int param );
	
	/* 	Function: setNodeParamstr
			Sets a property of a scene node.
		
		This function sets a specified property of the specified node to a specified value.
		The property must be of the type string (const char *).
		
		Parameters:
			node   - handle to the node to be modified
			param  - parameter to be modified
			value  - new value for the specified parameter
			
		Returns:
			true in case of success otherwise false
	*/
	DLL bool setNodeParamstr( NodeHandle node, int param, const char *value );


	/* 	Function: getNodeAABB
			Gets the bounding box of a scene node.
		
		This function stores the world coordinates of the axis aligned bounding box of a specified node in
		the specified variables. The bounding box is represented using the minimum and maximum coordinates
		on all three axes.
		
		Parameters:
			node              - handle to the node which will be accessed
			minX, minY, minZ  - pointers to variables where minimum coordinates will be stored
			maxX, maxY, maxZ  - pointers to variables where maximum coordinates will be stored
			
		Returns:
			true in case of success otherwise false
	*/
	DLL bool getNodeAABB( NodeHandle node, float *minX, float *minY, float *minZ,
	                      float *maxX, float *maxY, float *maxZ );
	
	/* 	Function: findNodes
			Finds scene nodes with the specified properties.
		
		This function loops recursively over all children of startNode and adds them to an internal list
		of results if they match the specified name and type. The result list is cleared each time this
		function is called. The function returns the number of nodes which were found and added to the list.
		
		Parameters:
			startNode  - handle to the node where the search begins
			name       - name of nodes to be searched (empty string for all nodes)
			type       - type of nodes to be searched (SceneNodeTypes::Undefined for all types)
			
		Returns:
			number of search results
	*/
	DLL int findNodes( NodeHandle startNode, const char *name, int type );
	
	/* 	Function: getNodeFindResult
			Gets a result from the findNodes query.
		
		This function returns the n-th (index) result of a previous findNodes query. The result is the handle
		to a scene node with the poperties specified at the findNodes query. If the index doesn't exist in the
		result list the function returns 0.
		
		Parameters:
			index  - index of search result
			
		Returns:
			handle to scene node from findNodes query or 0 if result doesn't exist
	*/
	DLL NodeHandle getNodeFindResult( int index );
	
	/* 	Function: castRay
			Performs a recursive ray collision query.
		
		This function checks recursively if the specified ray intersects the specified node or one of its children.
        The function finds intersections relative to the ray origin and returns the number of intersecting scene
        nodes. The ray is a line segment and is specified by a starting point (the origin) and a finite direction
		vector which also defines its length. Currently this function is limited to returning intersections with Meshes.
		For Meshes, the base LOD (LOD0) is always used for performing the ray-triangle intersection tests.
		
		Parameters:
			node        - node at which intersection check is beginning
			ox, oy, oz  - ray origin
			dx, dy, dz  - ray direction vector also specifying ray length
			numNearest  - maximum number of intersection points to be stored (0 for all)
			
		Returns:
			number of intersections
		*/
	DLL int castRay( NodeHandle node, float ox, float oy, float oz, float dx, float dy, float dz, int numNearest );

	/*	Function: getCastRayResult
			Returns a result of a previous castRay query.

		This functions is used to access the results of a previous castRay query. The index is used to access
		a specific result. The intersection data is copied to the specified variables.

		Parameters:
			index         - index of result to be accessed (range: 0 to number of results returned by castRay)
			node          - handle of intersected node
			distance      - distance from ray origin to intersection point
			intersection  - coordinates of intersection point (float[3] array)

		Returns:
			true if index was valid and data could be copied, otherwise false
	*/
	DLL bool getCastRayResult( int index, NodeHandle *node, float *distance, float *intersection );

	/*	Function: checkNodeVisibility
			Checks if a node is visible.

		This function checks if a specified node is visible from the perspective of a specified
		camera. The function always checks if the node is in the camera's frustum. If checkOcclusion
		is true, the function will take into account the occlusion culling information from the previous
		frame (if occlusion culling is disabled the flag is ignored). The flag calcLod determines whether the
		detail level for the node should be returned in case it is visible. The function returns -1 if the node
		is not visible, otherwise 0 (base LOD level) or the computed LOD level.

		Parameters:
			node            - node to be checked for visibility
			cameraNode      - camera node from which the visibility test is done
			checkOcclusion  - specifies if occlusion info from previous frame should be taken into account
			calcLod         - specifies if LOD level should be computed

		Returns:
			computed LOD level or -1 if node is not visible
	*/
	DLL int checkNodeVisibility( NodeHandle node, NodeHandle cameraNode, bool checkOcclusion, bool calcLod );


	/* Group: Group-specific scene graph functions */
	/* 	Function: addGroupNode
			Adds a Group node to the scene.
		
		This function creates a new Group node and attaches it to the specified parent node.
		
		Parameters:
			parent  - handle to parent node to which the new node will be attached
			name    - name of the node
			
		Returns:
			handle to the created node or 0 in case of failure
	*/
	DLL NodeHandle addGroupNode( NodeHandle parent, const char *name );
	
	
	/* Group: Model-specific scene graph functions */
	/* 	Function: addModelNode
			Adds a Model node to the scene.
		
		This function creates a new Model node and attaches it to the specified parent node.
		
		Parameters:
			parent       - handle to parent node to which the new node will be attached
			name         - name of the node
			geometryRes  - Geometry resource used by Model node
			
		Returns:
			handle to the created node or 0 in case of failure
	*/
	DLL NodeHandle addModelNode( NodeHandle parent, const char *name, ResHandle geometryRes );
	
	/* 	Function: setupModelAnimStage
			Configures an animation stage of a Model node.
		
		This function is used to setup the specified animation stage (channel) of the specified Model node.
		
		The function is used for animation blending. There is a fixed number of stages (by default 16) on
		which different animations can be played. The start node determines the first node (Joint or Mesh)
		to which the animation is recursively applied. If the start node is an empty string, the animation
		affects all animatable nodes (Joints and Meshes) of the model. If a NULL-handle is used for animationRes,
		the stage is cleared and the previous animation is removed.
		
		A simple way to do animation mixing is using additive animations. If a stage is configured to be
		additive  the engine calculates the difference between the current frame and the first frame in the
		animation and adds this delta to the current transformation of the joints or meshes.
		
		Parameters:
			modelNode     - handle to the Model node to be modified
			stage         - index of the animation stage to be configured
			animationRes  - handle to Animation resource (can be 0)
			startNode     - name of first node to which animation shall be applied (or empty string)
			additive      - flag indicating whether stage is additive
			
		Returns:
			true in case of success, otherwise false
	*/
	DLL bool setupModelAnimStage( NodeHandle modelNode, int stage, ResHandle animationRes,
	                              const char *startNode, bool additive );
	
	/* 	Function: setModelAnimParams
			Sets the parameters of an animation stage in a Model node.
		
		This function sets the current animation time and weight for a specified stage of the specified model.
		The time corresponds to the frames of the animation and the animation is looped if the
		time is higher than the maximum number of frames in the Animation resource. The weight is used for
		animation blending and determines how much influence the stage has compared to the other active
		stages. When the sum of the weights of all stages is more than one, the animations on the lower
		stages get priority.
		
		Parameters:
			modelNode  - handle to the Model node to be modified
			stage      - index of the animation stage to be modified
			time       - new animation time/frame
			weight     - new blend weight
			
		Returns:
			true in case of success, otherwise false
	*/
	DLL bool setModelAnimParams( NodeHandle modelNode, int stage, float time, float weight );
	
	/* 	Function: setModelMorpher
			Sets the weight of a morph target.
		
		This function sets the weight of a specified morph target. If the target parameter
		is an empty string the weight of all morph targets in the specified Model node is modified.
		If the specified morph target is not found the function returns false.
		
		Parameters:
			modelNode  - handle to the Model node to be modified
			target     - name of morph target
			weight     - new weight for morph target
			
		Returns:
			true in case of success, otherwise false
	*/
	DLL bool setModelMorpher( NodeHandle modelNode, const char *target, float weight );
	
	
	/* Group: Mesh-specific scene graph functions */
	/* 	Function: addMeshNode
			Adds a Mesh node to the scene.
		
		This function creates a new Mesh node and attaches it to the specified parent node.
		
		Parameters:
			parent       - handle to parent node to which the new node will be attached
			name         - name of the node
			materialRes  - material resource used by Mesh node
			batchStart   - first triangle index of mesh in Geometry resource of parent Model node
			batchCount   - number of triangle indices used for drawing mesh
			vertRStart   - first vertex in Geometry resource of parent Model node
			vertREnd     - last vertex in Geometry resource of parent Model node
			
		Returns:
			handle to the created node or 0 in case of failure
	*/
	DLL NodeHandle addMeshNode( NodeHandle parent, const char *name, ResHandle materialRes, 
	                            int batchStart, int batchCount, int vertRStart, int vertREnd );

	
	/* Group: Joint-specific scene graph functions */
	/* 	Function: addJointNode
			Adds a Joint node to the scene.
		
		This function creates a new Joint node and attaches it to the specified parent node.
		
		Parameters:
			parent      - handle to parent node to which the new node will be attached
			name        - name of the node
			jointIndex  - index of joint in Geometry resource of parent Model node
			
		Returns:
			handle to the created node or 0 in case of failure
	*/
	DLL NodeHandle addJointNode( NodeHandle parent, const char *name, int jointIndex );
	
	
	/* Group: Light-specific scene graph functions */
	/* 	Function: addLightNode
			Adds a Light node to the scene.
		
		This function creates a new Light node and attaches it to the specified parent node.
		The direction vector of the untransformed light node is pointing along the the negative
		z-axis. The specified material resource can define uniforms and projective textures.
		Furthermore it can contain a shader for doing lighting calculations if deferred shading
		is used. If no material is required the parameter can be zero. The context names
		define which shader contexts are used when rendering shadow maps or doing light calculations for
		forward rendering configurations.
		
		Parameters:
			parent           - handle to parent node to which the new node will be attached
			name             - name of the node
			materialRes      - material resource for light configuration or 0 if not used
			lightingContext  - name of the shader context used for doing light calculations
			shadowContext    - name of the shader context used for doing shadow map rendering
			
		Returns:
			handle to the created node or 0 in case of failure
	*/
	DLL NodeHandle addLightNode( NodeHandle parent, const char *name, ResHandle materialRes,
	                             const char *lightingContext, const char *shadowContext );
	
	/* 	Function: setLightContexts
			Sets the shader contexts used by a light source.
		
		This function sets the lighting and shadow shader contexts of the specified light source. The contexts
		define which shader code is used when doing lighting calculations or rendering the shadow map.
		
		Parameters:
			lightNode        - handle to the Light node to be modified
			lightingContext  - name of the shader context used for performing lighting calculations
			shadowContext    - name of the shader context used for rendering shadow maps
			
		Returns:
			true in case of success otherwise false
	*/
	DLL bool setLightContexts( NodeHandle lightNode, const char *lightingContext, const char *shadowContext );


	/* Group: Camera-specific scene graph functions */
	/* 	Function: addCameraNode
			Adds a Camera node to the scene.
		
		This function creates a new Camera node and attaches it to the specified parent node.
		
		Parameters:
			parent       - handle to parent node to which the new node will be attached
			name         - name of the node
			pipelineRes  - pipeline resource used for rendering
			
		Returns:
			handle to the created node or 0 in case of failure
	*/
	DLL NodeHandle addCameraNode( NodeHandle parent, const char *name, ResHandle pipelineRes );
	
	/* 	Function: setupCameraView
			Sets the planes of a camera viewing frustum.
		
		This function calculates the view frustum planes of the specified camera node using the specified view
		parameters.
		
		Parameters:
			cameraNode  - handle to the Camera node which will be modified
			fov         - field of view (FOV) angle
			aspect      - aspect ratio
			nearDist    - distance of near clipping plane
			farDist     - distance of far clipping plane 
			
		Returns:
			true in case of success otherwise false
	*/
	DLL bool setupCameraView( NodeHandle cameraNode, float fov, float aspect, float nearDist, float farDist );
	
	/* 	Function: getCameraProjectionMatrix
			Gets the camera projection matrix.
		
		This function gets the camera projection matrix used for bringing the geometry to
		screen space and copies it to the specified array.
		
		Parameters:
			cameraNode  - handle to Camera node
			projMat     - pointer to float array with 16 elements
			
		Returns:
			true in case of success otherwise false
	*/
	DLL bool getCameraProjectionMatrix( NodeHandle cameraNode, float *projMat );


	/* Group: Emitter-specific scene graph functions */
	/* 	Function: addEmitterNode
			Adds a Emitter node to the scene.
		
		This function creates a new Emitter node and attaches it to the specified parent node.
		
		Parameters:
			parent             - handle to parent node to which the new node will be attached
			name               - name of the node
			materialRes        - handle to Material resource used for rendering
			particleEffectRes  - handle to ParticleEffect resource used for configuring particle properties
			maxParticleCount   - maximal number of particles living at the same time
			respawnCount       - number of times a single particle is recreated after dying (-1 for infinite)
			
			
		Returns:
			handle to the created node or 0 in case of failure
	*/
	DLL NodeHandle addEmitterNode( NodeHandle parent, const char *name, ResHandle materialRes,
	                               ResHandle particleEffectRes, int maxParticleCount, int respawnCount );
	
	/* 	Function: advanceEmitterTime
			Advances the time value of an Emitter node.
		
		This function advances the simulation time of a particle system and continues the particle simulation
		with timeDelta being the time elapsed since the last call of this function. The specified
		node must be an Emitter node.
		
		Parameters:
			emitterNode  - handle to the Emitter node which will be modified
			timeDelta    - time delta in seconds
			
		Returns:
			true in case of success otherwise false
	*/
	DLL bool advanceEmitterTime( NodeHandle emitterNode, float timeDelta );

	/* 	Function: hasEmitterFinished
			Checks if an Emitter node is still alive.
		
		This function checks if a particle system is still active and has living particles or
		will spawn new particles. The specified node must be an Emitter node. The function can be
		used to check when a not infinitely running emitter for an effect like an explosion can be
		removed from the scene.
		
		Parameters:
			emitterNode  - handle to the Emitter node which is checked
			
		Returns:
			true if Emitter will no more emit any particles, otherwise or in case of failure false
	*/
	DLL bool hasEmitterFinished( NodeHandle emitterNode );
}

// ******************* End: Horde3D Header File ***************************//

#include <vcclr.h>
#include <string>
#include "Horde3DProxyHandler.h"

using namespace std;
using namespace System;
using namespace Infrastructure::Core::Server;

namespace Horde3D
{
	// Global instance
	NativeProxyHandler g_proxyHandler;

	// Function Pointer Typedefs
	typedef const char*(*h3dPtrGetVersionString)();
	typedef bool(*h3dPtrCheckExtension)(const char* extensionName);
	typedef bool(*h3dPtrInit)();
	typedef void(*h3dPtrRelease)();
	typedef void(*h3dPtrSetupViewport)(int x, int y, int width, int height, bool resizeBuffers);
	typedef bool(*h3dPtrRender)(NodeHandle cameraNode);
	typedef bool(*h3dPtrFinalizeFrame)();
	typedef void(*h3dPtrClear)();
	typedef const char*(*h3dPtrGetMessage)(int* level, float* time);
	typedef float(*h3dPtrGetOption)(EngineOptions::List param);
	typedef bool(*h3dPtrSetOption)(EngineOptions::List param, float value);
	typedef float(*h3dPtrGetStat)(EngineStats::List param, bool reset);
	typedef void(*h3dPtrShowOverlay)(float x_tl, float y_tl, float u_tl, float v_tl, float x_bl, float y_bl, float u_bl, float v_bl, float x_br, float y_br, float u_br, float v_br, float x_tr, float y_tr, float u_tr, float v_tr, float colR, float colG, float colB, float colA, ResHandle materialRes, int layer);
	typedef void(*h3dPtrClearOverlays)();
	typedef int(*h3dPtrGetResourceType)(ResHandle res);
	typedef const char*(*h3dPtrGetResourceName)(ResHandle res);
	typedef ResHandle(*h3dPtrGetNextResource)(int type, ResHandle start);
	typedef ResHandle(*h3dPtrFindResource)(int type, const char* name);
	typedef ResHandle(*h3dPtrAddResource)(int type, const char* name, int flags);
	typedef ResHandle(*h3dPtrCloneResource)(ResHandle sourceRes, const char* name);
	typedef int(*h3dPtrRemoveResource)(ResHandle res);
	typedef bool(*h3dPtrIsResourceLoaded)(ResHandle res);
	typedef bool(*h3dPtrLoadResource)(ResHandle res, const char* data, int size);
	typedef bool(*h3dPtrUnloadResource)(ResHandle res);
	typedef int(*h3dPtrGetResourceParami)(ResHandle res, int param);
	typedef bool(*h3dPtrSetResourceParami)(ResHandle res, int param, int value);
	typedef float(*h3dPtrGetResourceParamf)(ResHandle res, int param);
	typedef bool(*h3dPtrSetResourceParamf)(ResHandle res, int param, float value);
	typedef const char*(*h3dPtrGetResourceParamstr)(ResHandle res, int param);
	typedef bool(*h3dPtrSetResourceParamstr)(ResHandle res, int param, const char* value);
	typedef const void*(*h3dPtrGetResourceData)(ResHandle res, int param);
	typedef bool(*h3dPtrUpdateResourceData)(ResHandle res, int param, const void* data, int size);
	typedef ResHandle(*h3dPtrQueryUnloadedResource)(int index);
	typedef void(*h3dPtrReleaseUnusedResources)();
	typedef ResHandle(*h3dPtrCreateTexture2D)(const char* name, int flags, int width, int height, bool renderable);
	typedef void(*h3dPtrSetShaderPreambles)(const char* vertPreamble, const char* fragPreamble);
	typedef bool(*h3dPtrSetMaterialUniform)(ResHandle materialRes, const char* name, float a, float b, float c, float d);
	typedef bool(*h3dPtrSetPipelineStageActivation)(ResHandle pipelineRes, const char* stageName, bool enabled);
	typedef bool(*h3dPtrGetPipelineRenderTargetData)(ResHandle pipelineRes, const char* targetName, int bufIndex, int* width, int* height, int* compCount, float* dataBuffer, int bufferSize);
	typedef int(*h3dPtrGetNodeType)(NodeHandle node);
	typedef NodeHandle(*h3dPtrGetNodeParent)(NodeHandle node);
	typedef bool(*h3dPtrSetNodeParent)(NodeHandle node, NodeHandle parent);
	typedef NodeHandle(*h3dPtrGetNodeChild)(NodeHandle node, int index);
	typedef NodeHandle(*h3dPtrAddNodes)(NodeHandle parent, ResHandle sceneGraphRes);
	typedef bool(*h3dPtrRemoveNode)(NodeHandle node);
	typedef bool(*h3dPtrSetNodeActivation)(NodeHandle node, bool active);
	typedef bool(*h3dPtrCheckNodeTransformFlag)(NodeHandle node, bool reset);
	typedef bool(*h3dPtrGetNodeTransform)(NodeHandle node, float* tx, float* ty, float* tz, float* rx, float* ry, float* rz, float* sx, float* sy, float* sz);
	typedef bool(*h3dPtrSetNodeTransform)(NodeHandle node, float tx, float ty, float tz, float rx, float ry, float rz, float sx, float sy, float sz);
	typedef bool(*h3dPtrGetNodeTransformMatrices)(NodeHandle node, const float** relMat, const float** absMat);
	typedef bool(*h3dPtrSetNodeTransformMatrix)(NodeHandle node, const float* mat4x4);
	typedef float(*h3dPtrGetNodeParamf)(NodeHandle node, int param);
	typedef bool(*h3dPtrSetNodeParamf)(NodeHandle node, int param, float value);
	typedef int(*h3dPtrGetNodeParami)(NodeHandle node, int param);
	typedef bool(*h3dPtrSetNodeParami)(NodeHandle node, int param, int value);
	typedef const char*(*h3dPtrGetNodeParamstr)(NodeHandle node, int param);
	typedef bool(*h3dPtrSetNodeParamstr)(NodeHandle node, int param, const char* value);
	typedef bool(*h3dPtrGetNodeAABB)(NodeHandle node, float* minX, float* minY, float* minZ, float* maxX, float* maxY, float* maxZ);
	typedef int(*h3dPtrFindNodes)(NodeHandle startNode, const char* name, int type);
	typedef NodeHandle(*h3dPtrGetNodeFindResult)(int index);
	typedef int(*h3dPtrCastRay)(NodeHandle node, float ox, float oy, float oz, float dx, float dy, float dz, int numNearest);
	typedef bool(*h3dPtrGetCastRayResult)(int index, NodeHandle* node, float* distance, float* intersection);
	typedef int(*h3dPtrCheckNodeVisibility)(NodeHandle node, NodeHandle cameraNode, bool checkOcclusion, bool calcLod);
	typedef NodeHandle(*h3dPtrAddGroupNode)(NodeHandle parent, const char* name);
	typedef NodeHandle(*h3dPtrAddModelNode)(NodeHandle parent, const char* name, ResHandle geometryRes);
	typedef bool(*h3dPtrSetupModelAnimStage)(NodeHandle modelNode, int stage, ResHandle animationRes, const char* startNode, bool additive);
	typedef bool(*h3dPtrSetModelAnimParams)(NodeHandle modelNode, int stage, float time, float weight);
	typedef bool(*h3dPtrSetModelMorpher)(NodeHandle modelNode, const char* target, float weight);
	typedef NodeHandle(*h3dPtrAddMeshNode)(NodeHandle parent, const char* name, ResHandle materialRes, int batchStart, int batchCount, int vertRStart, int vertREnd);
	typedef NodeHandle(*h3dPtrAddJointNode)(NodeHandle parent, const char* name, int jointIndex);
	typedef NodeHandle(*h3dPtrAddLightNode)(NodeHandle parent, const char* name, ResHandle materialRes, const char* lightingContext, const char* shadowContext);
	typedef bool(*h3dPtrSetLightContexts)(NodeHandle lightNode, const char* lightingContext, const char* shadowContext);
	typedef NodeHandle(*h3dPtrAddCameraNode)(NodeHandle parent, const char* name, ResHandle pipelineRes);
	typedef bool(*h3dPtrSetupCameraView)(NodeHandle cameraNode, float fov, float aspect, float nearDist, float farDist);
	typedef bool(*h3dPtrGetCameraProjectionMatrix)(NodeHandle cameraNode, float* projMat);
	typedef NodeHandle(*h3dPtrAddEmitterNode)(NodeHandle parent, const char* name, ResHandle materialRes, ResHandle particleEffectRes, int maxParticleCount, int respawnCount);
	typedef bool(*h3dPtrAdvanceEmitterTime)(NodeHandle emitterNode, float timeDelta);
	typedef bool(*h3dPtrHasEmitterFinished)(NodeHandle emitterNode);

	
	class Horde3DProxyBase
	{	
	public:
		void Initialize(HINSTANCE dll)
		{			
			// Function Pointer Initialization
			h3dGetVersionString = (h3dPtrGetVersionString)(GetProcAddress(dll, "getVersionString"));
			if (h3dGetVersionString == 0)
				throw exception("Unable to find address of function 'getVersionString'.");

			h3dCheckExtension = (h3dPtrCheckExtension)(GetProcAddress(dll, "checkExtension"));
			if (h3dCheckExtension == 0)
				throw exception("Unable to find address of function 'checkExtension'.");

			h3dInit = (h3dPtrInit)(GetProcAddress(dll, "init"));
			if (h3dInit == 0)
				throw exception("Unable to find address of function 'init'.");

			h3dRelease = (h3dPtrRelease)(GetProcAddress(dll, "release"));
			if (h3dRelease == 0)
				throw exception("Unable to find address of function 'release'.");

			h3dSetupViewport = (h3dPtrSetupViewport)(GetProcAddress(dll, "setupViewport"));
			if (h3dSetupViewport == 0)
				throw exception("Unable to find address of function 'setupViewport'.");

			h3dRender = (h3dPtrRender)(GetProcAddress(dll, "render"));
			if (h3dRender == 0)
				throw exception("Unable to find address of function 'render'.");

			h3dFinalizeFrame = (h3dPtrFinalizeFrame)(GetProcAddress(dll, "finalizeFrame"));
			if (h3dFinalizeFrame == 0)
				throw exception("Unable to find address of function 'finalizeFrame'.");

			h3dClear = (h3dPtrClear)(GetProcAddress(dll, "clear"));
			if (h3dClear == 0)
				throw exception("Unable to find address of function 'clear'.");

			h3dGetMessage = (h3dPtrGetMessage)(GetProcAddress(dll, "getMessage"));
			if (h3dGetMessage == 0)
				throw exception("Unable to find address of function 'getMessage'.");

			h3dGetOption = (h3dPtrGetOption)(GetProcAddress(dll, "getOption"));
			if (h3dGetOption == 0)
				throw exception("Unable to find address of function 'getOption'.");

			h3dSetOption = (h3dPtrSetOption)(GetProcAddress(dll, "setOption"));
			if (h3dSetOption == 0)
				throw exception("Unable to find address of function 'setOption'.");

			h3dGetStat = (h3dPtrGetStat)(GetProcAddress(dll, "getStat"));
			if (h3dGetStat == 0)
				throw exception("Unable to find address of function 'getStat'.");

			h3dShowOverlay = (h3dPtrShowOverlay)(GetProcAddress(dll, "showOverlay"));
			if (h3dShowOverlay == 0)
				throw exception("Unable to find address of function 'showOverlay'.");

			h3dClearOverlays = (h3dPtrClearOverlays)(GetProcAddress(dll, "clearOverlays"));
			if (h3dClearOverlays == 0)
				throw exception("Unable to find address of function 'clearOverlays'.");

			h3dGetResourceType = (h3dPtrGetResourceType)(GetProcAddress(dll, "getResourceType"));
			if (h3dGetResourceType == 0)
				throw exception("Unable to find address of function 'getResourceType'.");

			h3dGetResourceName = (h3dPtrGetResourceName)(GetProcAddress(dll, "getResourceName"));
			if (h3dGetResourceName == 0)
				throw exception("Unable to find address of function 'getResourceName'.");

			h3dGetNextResource = (h3dPtrGetNextResource)(GetProcAddress(dll, "getNextResource"));
			if (h3dGetNextResource == 0)
				throw exception("Unable to find address of function 'getNextResource'.");

			h3dFindResource = (h3dPtrFindResource)(GetProcAddress(dll, "findResource"));
			if (h3dFindResource == 0)
				throw exception("Unable to find address of function 'findResource'.");

			h3dAddResource = (h3dPtrAddResource)(GetProcAddress(dll, "addResource"));
			if (h3dAddResource == 0)
				throw exception("Unable to find address of function 'addResource'.");

			h3dCloneResource = (h3dPtrCloneResource)(GetProcAddress(dll, "cloneResource"));
			if (h3dCloneResource == 0)
				throw exception("Unable to find address of function 'cloneResource'.");

			h3dRemoveResource = (h3dPtrRemoveResource)(GetProcAddress(dll, "removeResource"));
			if (h3dRemoveResource == 0)
				throw exception("Unable to find address of function 'removeResource'.");

			h3dIsResourceLoaded = (h3dPtrIsResourceLoaded)(GetProcAddress(dll, "isResourceLoaded"));
			if (h3dIsResourceLoaded == 0)
				throw exception("Unable to find address of function 'isResourceLoaded'.");

			h3dLoadResource = (h3dPtrLoadResource)(GetProcAddress(dll, "loadResource"));
			if (h3dLoadResource == 0)
				throw exception("Unable to find address of function 'loadResource'.");

			h3dUnloadResource = (h3dPtrUnloadResource)(GetProcAddress(dll, "unloadResource"));
			if (h3dUnloadResource == 0)
				throw exception("Unable to find address of function 'unloadResource'.");

			h3dGetResourceParami = (h3dPtrGetResourceParami)(GetProcAddress(dll, "getResourceParami"));
			if (h3dGetResourceParami == 0)
				throw exception("Unable to find address of function 'getResourceParami'.");

			h3dSetResourceParami = (h3dPtrSetResourceParami)(GetProcAddress(dll, "setResourceParami"));
			if (h3dSetResourceParami == 0)
				throw exception("Unable to find address of function 'setResourceParami'.");

			h3dGetResourceParamf = (h3dPtrGetResourceParamf)(GetProcAddress(dll, "getResourceParamf"));
			if (h3dGetResourceParamf == 0)
				throw exception("Unable to find address of function 'getResourceParamf'.");

			h3dSetResourceParamf = (h3dPtrSetResourceParamf)(GetProcAddress(dll, "setResourceParamf"));
			if (h3dSetResourceParamf == 0)
				throw exception("Unable to find address of function 'setResourceParamf'.");

			h3dGetResourceParamstr = (h3dPtrGetResourceParamstr)(GetProcAddress(dll, "getResourceParamstr"));
			if (h3dGetResourceParamstr == 0)
				throw exception("Unable to find address of function 'getResourceParamstr'.");

			h3dSetResourceParamstr = (h3dPtrSetResourceParamstr)(GetProcAddress(dll, "setResourceParamstr"));
			if (h3dSetResourceParamstr == 0)
				throw exception("Unable to find address of function 'setResourceParamstr'.");

			h3dGetResourceData = (h3dPtrGetResourceData)(GetProcAddress(dll, "getResourceData"));
			if (h3dGetResourceData == 0)
				throw exception("Unable to find address of function 'getResourceData'.");

			h3dUpdateResourceData = (h3dPtrUpdateResourceData)(GetProcAddress(dll, "updateResourceData"));
			if (h3dUpdateResourceData == 0)
				throw exception("Unable to find address of function 'updateResourceData'.");

			h3dQueryUnloadedResource = (h3dPtrQueryUnloadedResource)(GetProcAddress(dll, "queryUnloadedResource"));
			if (h3dQueryUnloadedResource == 0)
				throw exception("Unable to find address of function 'queryUnloadedResource'.");

			h3dReleaseUnusedResources = (h3dPtrReleaseUnusedResources)(GetProcAddress(dll, "releaseUnusedResources"));
			if (h3dReleaseUnusedResources == 0)
				throw exception("Unable to find address of function 'releaseUnusedResources'.");

			h3dCreateTexture2D = (h3dPtrCreateTexture2D)(GetProcAddress(dll, "createTexture2D"));
			if (h3dCreateTexture2D == 0)
				throw exception("Unable to find address of function 'createTexture2D'.");

			h3dSetShaderPreambles = (h3dPtrSetShaderPreambles)(GetProcAddress(dll, "setShaderPreambles"));
			if (h3dSetShaderPreambles == 0)
				throw exception("Unable to find address of function 'setShaderPreambles'.");

			h3dSetMaterialUniform = (h3dPtrSetMaterialUniform)(GetProcAddress(dll, "setMaterialUniform"));
			if (h3dSetMaterialUniform == 0)
				throw exception("Unable to find address of function 'setMaterialUniform'.");

			h3dSetPipelineStageActivation = (h3dPtrSetPipelineStageActivation)(GetProcAddress(dll, "setPipelineStageActivation"));
			if (h3dSetPipelineStageActivation == 0)
				throw exception("Unable to find address of function 'setPipelineStageActivation'.");

			h3dGetPipelineRenderTargetData = (h3dPtrGetPipelineRenderTargetData)(GetProcAddress(dll, "getPipelineRenderTargetData"));
			if (h3dGetPipelineRenderTargetData == 0)
				throw exception("Unable to find address of function 'getPipelineRenderTargetData'.");

			h3dGetNodeType = (h3dPtrGetNodeType)(GetProcAddress(dll, "getNodeType"));
			if (h3dGetNodeType == 0)
				throw exception("Unable to find address of function 'getNodeType'.");

			h3dGetNodeParent = (h3dPtrGetNodeParent)(GetProcAddress(dll, "getNodeParent"));
			if (h3dGetNodeParent == 0)
				throw exception("Unable to find address of function 'getNodeParent'.");

			h3dSetNodeParent = (h3dPtrSetNodeParent)(GetProcAddress(dll, "setNodeParent"));
			if (h3dSetNodeParent == 0)
				throw exception("Unable to find address of function 'setNodeParent'.");

			h3dGetNodeChild = (h3dPtrGetNodeChild)(GetProcAddress(dll, "getNodeChild"));
			if (h3dGetNodeChild == 0)
				throw exception("Unable to find address of function 'getNodeChild'.");

			h3dAddNodes = (h3dPtrAddNodes)(GetProcAddress(dll, "addNodes"));
			if (h3dAddNodes == 0)
				throw exception("Unable to find address of function 'addNodes'.");

			h3dRemoveNode = (h3dPtrRemoveNode)(GetProcAddress(dll, "removeNode"));
			if (h3dRemoveNode == 0)
				throw exception("Unable to find address of function 'removeNode'.");

			h3dSetNodeActivation = (h3dPtrSetNodeActivation)(GetProcAddress(dll, "setNodeActivation"));
			if (h3dSetNodeActivation == 0)
				throw exception("Unable to find address of function 'setNodeActivation'.");

			h3dCheckNodeTransformFlag = (h3dPtrCheckNodeTransformFlag)(GetProcAddress(dll, "checkNodeTransformFlag"));
			if (h3dCheckNodeTransformFlag == 0)
				throw exception("Unable to find address of function 'checkNodeTransformFlag'.");

			h3dGetNodeTransform = (h3dPtrGetNodeTransform)(GetProcAddress(dll, "getNodeTransform"));
			if (h3dGetNodeTransform == 0)
				throw exception("Unable to find address of function 'getNodeTransform'.");

			h3dSetNodeTransform = (h3dPtrSetNodeTransform)(GetProcAddress(dll, "setNodeTransform"));
			if (h3dSetNodeTransform == 0)
				throw exception("Unable to find address of function 'setNodeTransform'.");

			h3dGetNodeTransformMatrices = (h3dPtrGetNodeTransformMatrices)(GetProcAddress(dll, "getNodeTransformMatrices"));
			if (h3dGetNodeTransformMatrices == 0)
				throw exception("Unable to find address of function 'getNodeTransformMatrices'.");

			h3dSetNodeTransformMatrix = (h3dPtrSetNodeTransformMatrix)(GetProcAddress(dll, "setNodeTransformMatrix"));
			if (h3dSetNodeTransformMatrix == 0)
				throw exception("Unable to find address of function 'setNodeTransformMatrix'.");

			h3dGetNodeParamf = (h3dPtrGetNodeParamf)(GetProcAddress(dll, "getNodeParamf"));
			if (h3dGetNodeParamf == 0)
				throw exception("Unable to find address of function 'getNodeParamf'.");

			h3dSetNodeParamf = (h3dPtrSetNodeParamf)(GetProcAddress(dll, "setNodeParamf"));
			if (h3dSetNodeParamf == 0)
				throw exception("Unable to find address of function 'setNodeParamf'.");

			h3dGetNodeParami = (h3dPtrGetNodeParami)(GetProcAddress(dll, "getNodeParami"));
			if (h3dGetNodeParami == 0)
				throw exception("Unable to find address of function 'getNodeParami'.");

			h3dSetNodeParami = (h3dPtrSetNodeParami)(GetProcAddress(dll, "setNodeParami"));
			if (h3dSetNodeParami == 0)
				throw exception("Unable to find address of function 'setNodeParami'.");

			h3dGetNodeParamstr = (h3dPtrGetNodeParamstr)(GetProcAddress(dll, "getNodeParamstr"));
			if (h3dGetNodeParamstr == 0)
				throw exception("Unable to find address of function 'getNodeParamstr'.");

			h3dSetNodeParamstr = (h3dPtrSetNodeParamstr)(GetProcAddress(dll, "setNodeParamstr"));
			if (h3dSetNodeParamstr == 0)
				throw exception("Unable to find address of function 'setNodeParamstr'.");

			h3dGetNodeAABB = (h3dPtrGetNodeAABB)(GetProcAddress(dll, "getNodeAABB"));
			if (h3dGetNodeAABB == 0)
				throw exception("Unable to find address of function 'getNodeAABB'.");

			h3dFindNodes = (h3dPtrFindNodes)(GetProcAddress(dll, "findNodes"));
			if (h3dFindNodes == 0)
				throw exception("Unable to find address of function 'findNodes'.");

			h3dGetNodeFindResult = (h3dPtrGetNodeFindResult)(GetProcAddress(dll, "getNodeFindResult"));
			if (h3dGetNodeFindResult == 0)
				throw exception("Unable to find address of function 'getNodeFindResult'.");

			h3dCastRay = (h3dPtrCastRay)(GetProcAddress(dll, "castRay"));
			if (h3dCastRay == 0)
				throw exception("Unable to find address of function 'castRay'.");

			h3dGetCastRayResult = (h3dPtrGetCastRayResult)(GetProcAddress(dll, "getCastRayResult"));
			if (h3dGetCastRayResult == 0)
				throw exception("Unable to find address of function 'getCastRayResult'.");

			h3dCheckNodeVisibility = (h3dPtrCheckNodeVisibility)(GetProcAddress(dll, "checkNodeVisibility"));
			if (h3dCheckNodeVisibility == 0)
				throw exception("Unable to find address of function 'checkNodeVisibility'.");

			h3dAddGroupNode = (h3dPtrAddGroupNode)(GetProcAddress(dll, "addGroupNode"));
			if (h3dAddGroupNode == 0)
				throw exception("Unable to find address of function 'addGroupNode'.");

			h3dAddModelNode = (h3dPtrAddModelNode)(GetProcAddress(dll, "addModelNode"));
			if (h3dAddModelNode == 0)
				throw exception("Unable to find address of function 'addModelNode'.");

			h3dSetupModelAnimStage = (h3dPtrSetupModelAnimStage)(GetProcAddress(dll, "setupModelAnimStage"));
			if (h3dSetupModelAnimStage == 0)
				throw exception("Unable to find address of function 'setupModelAnimStage'.");

			h3dSetModelAnimParams = (h3dPtrSetModelAnimParams)(GetProcAddress(dll, "setModelAnimParams"));
			if (h3dSetModelAnimParams == 0)
				throw exception("Unable to find address of function 'setModelAnimParams'.");

			h3dSetModelMorpher = (h3dPtrSetModelMorpher)(GetProcAddress(dll, "setModelMorpher"));
			if (h3dSetModelMorpher == 0)
				throw exception("Unable to find address of function 'setModelMorpher'.");

			h3dAddMeshNode = (h3dPtrAddMeshNode)(GetProcAddress(dll, "addMeshNode"));
			if (h3dAddMeshNode == 0)
				throw exception("Unable to find address of function 'addMeshNode'.");

			h3dAddJointNode = (h3dPtrAddJointNode)(GetProcAddress(dll, "addJointNode"));
			if (h3dAddJointNode == 0)
				throw exception("Unable to find address of function 'addJointNode'.");

			h3dAddLightNode = (h3dPtrAddLightNode)(GetProcAddress(dll, "addLightNode"));
			if (h3dAddLightNode == 0)
				throw exception("Unable to find address of function 'addLightNode'.");

			h3dSetLightContexts = (h3dPtrSetLightContexts)(GetProcAddress(dll, "setLightContexts"));
			if (h3dSetLightContexts == 0)
				throw exception("Unable to find address of function 'setLightContexts'.");

			h3dAddCameraNode = (h3dPtrAddCameraNode)(GetProcAddress(dll, "addCameraNode"));
			if (h3dAddCameraNode == 0)
				throw exception("Unable to find address of function 'addCameraNode'.");

			h3dSetupCameraView = (h3dPtrSetupCameraView)(GetProcAddress(dll, "setupCameraView"));
			if (h3dSetupCameraView == 0)
				throw exception("Unable to find address of function 'setupCameraView'.");

			h3dGetCameraProjectionMatrix = (h3dPtrGetCameraProjectionMatrix)(GetProcAddress(dll, "getCameraProjectionMatrix"));
			if (h3dGetCameraProjectionMatrix == 0)
				throw exception("Unable to find address of function 'getCameraProjectionMatrix'.");

			h3dAddEmitterNode = (h3dPtrAddEmitterNode)(GetProcAddress(dll, "addEmitterNode"));
			if (h3dAddEmitterNode == 0)
				throw exception("Unable to find address of function 'addEmitterNode'.");

			h3dAdvanceEmitterTime = (h3dPtrAdvanceEmitterTime)(GetProcAddress(dll, "advanceEmitterTime"));
			if (h3dAdvanceEmitterTime == 0)
				throw exception("Unable to find address of function 'advanceEmitterTime'.");

			h3dHasEmitterFinished = (h3dPtrHasEmitterFinished)(GetProcAddress(dll, "hasEmitterFinished"));
			if (h3dHasEmitterFinished == 0)
				throw exception("Unable to find address of function 'hasEmitterFinished'.");


		}
		

		Horde3DProxyBase()
		{
		}
		
		virtual ~Horde3DProxyBase() 
		{
		}

		// Virtual functions
		virtual const char* GetVersionString() = 0;
		
		virtual bool CheckExtension(const char* extensionName) = 0;
		
		virtual bool Init() = 0;
		
		virtual void Release() = 0;
		
		virtual void SetupViewport(int x, int y, int width, int height, bool resizeBuffers) = 0;
		
		virtual bool Render(NodeHandle cameraNode) = 0;
		
		virtual bool FinalizeFrame() = 0;
		
		virtual void Clear() = 0;
		
		virtual const char* GetMessage(int* level, float* time) = 0;
		
		virtual float GetOption(EngineOptions::List param) = 0;
		
		virtual bool SetOption(EngineOptions::List param, float value) = 0;
		
		virtual float GetStat(EngineStats::List param, bool reset) = 0;
		
		virtual void ShowOverlay(float x_tl, float y_tl, float u_tl, float v_tl, float x_bl, float y_bl, float u_bl, float v_bl, float x_br, float y_br, float u_br, float v_br, float x_tr, float y_tr, float u_tr, float v_tr, float colR, float colG, float colB, float colA, ResHandle materialRes, int layer) = 0;
		
		virtual void ClearOverlays() = 0;
		
		virtual int GetResourceType(ResHandle res) = 0;
		
		virtual const char* GetResourceName(ResHandle res) = 0;
		
		virtual ResHandle GetNextResource(int type, ResHandle start) = 0;
		
		virtual ResHandle FindResource(int type, const char* name) = 0;
		
		virtual ResHandle AddResource(int type, const char* name, int flags) = 0;
		
		virtual ResHandle CloneResource(ResHandle sourceRes, const char* name) = 0;
		
		virtual int RemoveResource(ResHandle res) = 0;
		
		virtual bool IsResourceLoaded(ResHandle res) = 0;
		
		virtual bool LoadResource(ResHandle res, const char* data, int size) = 0;
		
		virtual bool UnloadResource(ResHandle res) = 0;
		
		virtual int GetResourceParami(ResHandle res, int param) = 0;
		
		virtual bool SetResourceParami(ResHandle res, int param, int value) = 0;
		
		virtual float GetResourceParamf(ResHandle res, int param) = 0;
		
		virtual bool SetResourceParamf(ResHandle res, int param, float value) = 0;
		
		virtual const char* GetResourceParamstr(ResHandle res, int param) = 0;
		
		virtual bool SetResourceParamstr(ResHandle res, int param, const char* value) = 0;
		
		virtual const void* GetResourceData(ResHandle res, int param) = 0;
		
		virtual bool UpdateResourceData(ResHandle res, int param, const void* data, int size) = 0;
		
		virtual ResHandle QueryUnloadedResource(int index) = 0;
		
		virtual void ReleaseUnusedResources() = 0;
		
		virtual ResHandle CreateTexture2D(const char* name, int flags, int width, int height, bool renderable) = 0;
		
		virtual void SetShaderPreambles(const char* vertPreamble, const char* fragPreamble) = 0;
		
		virtual bool SetMaterialUniform(ResHandle materialRes, const char* name, float a, float b, float c, float d) = 0;
		
		virtual bool SetPipelineStageActivation(ResHandle pipelineRes, const char* stageName, bool enabled) = 0;
		
		virtual bool GetPipelineRenderTargetData(ResHandle pipelineRes, const char* targetName, int bufIndex, int* width, int* height, int* compCount, float* dataBuffer, int bufferSize) = 0;
		
		virtual int GetNodeType(NodeHandle node) = 0;
		
		virtual NodeHandle GetNodeParent(NodeHandle node) = 0;
		
		virtual bool SetNodeParent(NodeHandle node, NodeHandle parent) = 0;
		
		virtual NodeHandle GetNodeChild(NodeHandle node, int index) = 0;
		
		virtual NodeHandle AddNodes(NodeHandle parent, ResHandle sceneGraphRes) = 0;
		
		virtual bool RemoveNode(NodeHandle node) = 0;
		
		virtual bool SetNodeActivation(NodeHandle node, bool active) = 0;
		
		virtual bool CheckNodeTransformFlag(NodeHandle node, bool reset) = 0;
		
		virtual bool GetNodeTransform(NodeHandle node, float* tx, float* ty, float* tz, float* rx, float* ry, float* rz, float* sx, float* sy, float* sz) = 0;
		
		virtual bool SetNodeTransform(NodeHandle node, float tx, float ty, float tz, float rx, float ry, float rz, float sx, float sy, float sz) = 0;
		
		virtual bool GetNodeTransformMatrices(NodeHandle node, const float* * relMat, const float* * absMat) = 0;
		
		virtual bool SetNodeTransformMatrix(NodeHandle node, const float* mat4x4) = 0;
		
		virtual float GetNodeParamf(NodeHandle node, int param) = 0;
		
		virtual bool SetNodeParamf(NodeHandle node, int param, float value) = 0;
		
		virtual int GetNodeParami(NodeHandle node, int param) = 0;
		
		virtual bool SetNodeParami(NodeHandle node, int param, int value) = 0;
		
		virtual const char* GetNodeParamstr(NodeHandle node, int param) = 0;
		
		virtual bool SetNodeParamstr(NodeHandle node, int param, const char* value) = 0;
		
		virtual bool GetNodeAABB(NodeHandle node, float* minX, float* minY, float* minZ, float* maxX, float* maxY, float* maxZ) = 0;
		
		virtual int FindNodes(NodeHandle startNode, const char* name, int type) = 0;
		
		virtual NodeHandle GetNodeFindResult(int index) = 0;
		
		virtual int CastRay(NodeHandle node, float ox, float oy, float oz, float dx, float dy, float dz, int numNearest) = 0;
		
		virtual bool GetCastRayResult(int index, NodeHandle* node, float* distance, float* intersection) = 0;
		
		virtual int CheckNodeVisibility(NodeHandle node, NodeHandle cameraNode, bool checkOcclusion, bool calcLod) = 0;
		
		virtual NodeHandle AddGroupNode(NodeHandle parent, const char* name) = 0;
		
		virtual NodeHandle AddModelNode(NodeHandle parent, const char* name, ResHandle geometryRes) = 0;
		
		virtual bool SetupModelAnimStage(NodeHandle modelNode, int stage, ResHandle animationRes, const char* startNode, bool additive) = 0;
		
		virtual bool SetModelAnimParams(NodeHandle modelNode, int stage, float time, float weight) = 0;
		
		virtual bool SetModelMorpher(NodeHandle modelNode, const char* target, float weight) = 0;
		
		virtual NodeHandle AddMeshNode(NodeHandle parent, const char* name, ResHandle materialRes, int batchStart, int batchCount, int vertRStart, int vertREnd) = 0;
		
		virtual NodeHandle AddJointNode(NodeHandle parent, const char* name, int jointIndex) = 0;
		
		virtual NodeHandle AddLightNode(NodeHandle parent, const char* name, ResHandle materialRes, const char* lightingContext, const char* shadowContext) = 0;
		
		virtual bool SetLightContexts(NodeHandle lightNode, const char* lightingContext, const char* shadowContext) = 0;
		
		virtual NodeHandle AddCameraNode(NodeHandle parent, const char* name, ResHandle pipelineRes) = 0;
		
		virtual bool SetupCameraView(NodeHandle cameraNode, float fov, float aspect, float nearDist, float farDist) = 0;
		
		virtual bool GetCameraProjectionMatrix(NodeHandle cameraNode, float* projMat) = 0;
		
		virtual NodeHandle AddEmitterNode(NodeHandle parent, const char* name, ResHandle materialRes, ResHandle particleEffectRes, int maxParticleCount, int respawnCount) = 0;
		
		virtual bool AdvanceEmitterTime(NodeHandle emitterNode, float timeDelta) = 0;
		
		virtual bool HasEmitterFinished(NodeHandle emitterNode) = 0;
		

		
	protected:
		// Function Pointer Definitions
		h3dPtrGetVersionString h3dGetVersionString;
		h3dPtrCheckExtension h3dCheckExtension;
		h3dPtrInit h3dInit;
		h3dPtrRelease h3dRelease;
		h3dPtrSetupViewport h3dSetupViewport;
		h3dPtrRender h3dRender;
		h3dPtrFinalizeFrame h3dFinalizeFrame;
		h3dPtrClear h3dClear;
		h3dPtrGetMessage h3dGetMessage;
		h3dPtrGetOption h3dGetOption;
		h3dPtrSetOption h3dSetOption;
		h3dPtrGetStat h3dGetStat;
		h3dPtrShowOverlay h3dShowOverlay;
		h3dPtrClearOverlays h3dClearOverlays;
		h3dPtrGetResourceType h3dGetResourceType;
		h3dPtrGetResourceName h3dGetResourceName;
		h3dPtrGetNextResource h3dGetNextResource;
		h3dPtrFindResource h3dFindResource;
		h3dPtrAddResource h3dAddResource;
		h3dPtrCloneResource h3dCloneResource;
		h3dPtrRemoveResource h3dRemoveResource;
		h3dPtrIsResourceLoaded h3dIsResourceLoaded;
		h3dPtrLoadResource h3dLoadResource;
		h3dPtrUnloadResource h3dUnloadResource;
		h3dPtrGetResourceParami h3dGetResourceParami;
		h3dPtrSetResourceParami h3dSetResourceParami;
		h3dPtrGetResourceParamf h3dGetResourceParamf;
		h3dPtrSetResourceParamf h3dSetResourceParamf;
		h3dPtrGetResourceParamstr h3dGetResourceParamstr;
		h3dPtrSetResourceParamstr h3dSetResourceParamstr;
		h3dPtrGetResourceData h3dGetResourceData;
		h3dPtrUpdateResourceData h3dUpdateResourceData;
		h3dPtrQueryUnloadedResource h3dQueryUnloadedResource;
		h3dPtrReleaseUnusedResources h3dReleaseUnusedResources;
		h3dPtrCreateTexture2D h3dCreateTexture2D;
		h3dPtrSetShaderPreambles h3dSetShaderPreambles;
		h3dPtrSetMaterialUniform h3dSetMaterialUniform;
		h3dPtrSetPipelineStageActivation h3dSetPipelineStageActivation;
		h3dPtrGetPipelineRenderTargetData h3dGetPipelineRenderTargetData;
		h3dPtrGetNodeType h3dGetNodeType;
		h3dPtrGetNodeParent h3dGetNodeParent;
		h3dPtrSetNodeParent h3dSetNodeParent;
		h3dPtrGetNodeChild h3dGetNodeChild;
		h3dPtrAddNodes h3dAddNodes;
		h3dPtrRemoveNode h3dRemoveNode;
		h3dPtrSetNodeActivation h3dSetNodeActivation;
		h3dPtrCheckNodeTransformFlag h3dCheckNodeTransformFlag;
		h3dPtrGetNodeTransform h3dGetNodeTransform;
		h3dPtrSetNodeTransform h3dSetNodeTransform;
		h3dPtrGetNodeTransformMatrices h3dGetNodeTransformMatrices;
		h3dPtrSetNodeTransformMatrix h3dSetNodeTransformMatrix;
		h3dPtrGetNodeParamf h3dGetNodeParamf;
		h3dPtrSetNodeParamf h3dSetNodeParamf;
		h3dPtrGetNodeParami h3dGetNodeParami;
		h3dPtrSetNodeParami h3dSetNodeParami;
		h3dPtrGetNodeParamstr h3dGetNodeParamstr;
		h3dPtrSetNodeParamstr h3dSetNodeParamstr;
		h3dPtrGetNodeAABB h3dGetNodeAABB;
		h3dPtrFindNodes h3dFindNodes;
		h3dPtrGetNodeFindResult h3dGetNodeFindResult;
		h3dPtrCastRay h3dCastRay;
		h3dPtrGetCastRayResult h3dGetCastRayResult;
		h3dPtrCheckNodeVisibility h3dCheckNodeVisibility;
		h3dPtrAddGroupNode h3dAddGroupNode;
		h3dPtrAddModelNode h3dAddModelNode;
		h3dPtrSetupModelAnimStage h3dSetupModelAnimStage;
		h3dPtrSetModelAnimParams h3dSetModelAnimParams;
		h3dPtrSetModelMorpher h3dSetModelMorpher;
		h3dPtrAddMeshNode h3dAddMeshNode;
		h3dPtrAddJointNode h3dAddJointNode;
		h3dPtrAddLightNode h3dAddLightNode;
		h3dPtrSetLightContexts h3dSetLightContexts;
		h3dPtrAddCameraNode h3dAddCameraNode;
		h3dPtrSetupCameraView h3dSetupCameraView;
		h3dPtrGetCameraProjectionMatrix h3dGetCameraProjectionMatrix;
		h3dPtrAddEmitterNode h3dAddEmitterNode;
		h3dPtrAdvanceEmitterTime h3dAdvanceEmitterTime;
		h3dPtrHasEmitterFinished h3dHasEmitterFinished;

	};

	class Horde3DProfilingProxy : public Horde3DProxyBase
	{
	private:
		gcroot<System::Diagnostics::Stopwatch^> stopwatch;

	public:
		virtual ~Horde3DProfilingProxy() 
		{
			stopwatch->Stop();
			stopwatch = nullptr;
		}

		Horde3DProfilingProxy()
		{
			stopwatch = gcnew System::Diagnostics::Stopwatch();
			stopwatch->Start();
		}

		// Horde3D Profiling Function Proxies
		const char* GetVersionString()
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			const char* returnValue = h3dGetVersionString();
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			System::Object^ result = (System::Object^)(gcnew System::String(returnValue));
			array<System::Object^>^ parameters = nullptr;
		
			Horde3DCall::RegisterFunctionCall("getVersionString", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnGetVersionString(gcnew System::String(returnValue));
		
			return returnValue;
		}
		
		bool CheckExtension(const char* extensionName)
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			bool returnValue = h3dCheckExtension(extensionName);
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			System::Object^ result = (System::Object^)(returnValue);
			array<System::Object^>^ parameters = gcnew array<System::Object^>(1);
		
			parameters[0] = (System::Object^)(gcnew System::String(extensionName));
		
			Horde3DCall::RegisterFunctionCall("checkExtension", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnCheckExtension(returnValue, gcnew System::String(extensionName));
		
			return returnValue;
		}
		
		bool Init()
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			bool returnValue = h3dInit();
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			System::Object^ result = (System::Object^)(returnValue);
			array<System::Object^>^ parameters = nullptr;
		
			Horde3DCall::RegisterFunctionCall("init", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnInit(returnValue);
		
			return returnValue;
		}
		
		void Release()
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			h3dRelease();
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			System::Object^ result = nullptr;
			array<System::Object^>^ parameters = nullptr;
		
			Horde3DCall::RegisterFunctionCall("release", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnRelease();
		
		}
		
		void SetupViewport(int x, int y, int width, int height, bool resizeBuffers)
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			h3dSetupViewport(x, y, width, height, resizeBuffers);
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			System::Object^ result = nullptr;
			array<System::Object^>^ parameters = gcnew array<System::Object^>(5);
		
			parameters[0] = (System::Object^)(x);
			parameters[1] = (System::Object^)(y);
			parameters[2] = (System::Object^)(width);
			parameters[3] = (System::Object^)(height);
			parameters[4] = (System::Object^)(resizeBuffers);
		
			Horde3DCall::RegisterFunctionCall("setupViewport", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnSetupViewport(x, y, width, height, resizeBuffers);
		
		}
		
		bool Render(NodeHandle cameraNode)
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			bool returnValue = h3dRender(cameraNode);
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			System::Object^ result = (System::Object^)(returnValue);
			array<System::Object^>^ parameters = gcnew array<System::Object^>(1);
		
			parameters[0] = (System::Object^)((int)cameraNode);
		
			Horde3DCall::RegisterFunctionCall("render", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnRender(returnValue, (int)cameraNode);
		
			return returnValue;
		}
		
		bool FinalizeFrame()
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			bool returnValue = h3dFinalizeFrame();
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			System::Object^ result = (System::Object^)(returnValue);
			array<System::Object^>^ parameters = nullptr;
		
			Horde3DCall::RegisterFunctionCall("finalizeFrame", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnFinalizeFrame(returnValue);
		
			return returnValue;
		}
		
		void Clear()
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			h3dClear();
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			System::Object^ result = nullptr;
			array<System::Object^>^ parameters = nullptr;
		
			Horde3DCall::RegisterFunctionCall("clear", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnClear();
		
		}
		
		const char* GetMessage(int* level, float* time)
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			const char* returnValue = h3dGetMessage(level, time);
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			System::Object^ result = (System::Object^)(gcnew System::String(returnValue));
			array<System::Object^>^ parameters = gcnew array<System::Object^>(2);
		
			parameters[0] = (System::Object^)(level == 0 ? 0 : *level);
			parameters[1] = (System::Object^)(time == 0 ? 0 : *time);
		
			Horde3DCall::RegisterFunctionCall("getMessage", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnGetMessage(gcnew System::String(returnValue), level == 0 ? 0 : *level, time == 0 ? 0 : *time);
		
			return returnValue;
		}
		
		float GetOption(EngineOptions::List param)
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			float returnValue = h3dGetOption(param);
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			System::Object^ result = (System::Object^)(returnValue);
			array<System::Object^>^ parameters = gcnew array<System::Object^>(1);
		
			parameters[0] = (System::Object^)((int)param);
		
			Horde3DCall::RegisterFunctionCall("getOption", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnGetOption(returnValue, (int)param);
		
			return returnValue;
		}
		
		bool SetOption(EngineOptions::List param, float value)
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			bool returnValue = h3dSetOption(param, value);
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			System::Object^ result = (System::Object^)(returnValue);
			array<System::Object^>^ parameters = gcnew array<System::Object^>(2);
		
			parameters[0] = (System::Object^)((int)param);
			parameters[1] = (System::Object^)(value);
		
			Horde3DCall::RegisterFunctionCall("setOption", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnSetOption(returnValue, (int)param, value);
		
			return returnValue;
		}
		
		float GetStat(EngineStats::List param, bool reset)
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			float returnValue = h3dGetStat(param, reset);
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			System::Object^ result = (System::Object^)(returnValue);
			array<System::Object^>^ parameters = gcnew array<System::Object^>(2);
		
			parameters[0] = (System::Object^)((int)param);
			parameters[1] = (System::Object^)(reset);
		
			Horde3DCall::RegisterFunctionCall("getStat", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnGetStat(returnValue, (int)param, reset);
		
			return returnValue;
		}
		
		void ShowOverlay(float x_tl, float y_tl, float u_tl, float v_tl, float x_bl, float y_bl, float u_bl, float v_bl, float x_br, float y_br, float u_br, float v_br, float x_tr, float y_tr, float u_tr, float v_tr, float colR, float colG, float colB, float colA, ResHandle materialRes, int layer)
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			h3dShowOverlay(x_tl, y_tl, u_tl, v_tl, x_bl, y_bl, u_bl, v_bl, x_br, y_br, u_br, v_br, x_tr, y_tr, u_tr, v_tr, colR, colG, colB, colA, materialRes, layer);
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			System::Object^ result = nullptr;
			array<System::Object^>^ parameters = gcnew array<System::Object^>(22);
		
			parameters[0] = (System::Object^)(x_tl);
			parameters[1] = (System::Object^)(y_tl);
			parameters[2] = (System::Object^)(u_tl);
			parameters[3] = (System::Object^)(v_tl);
			parameters[4] = (System::Object^)(x_bl);
			parameters[5] = (System::Object^)(y_bl);
			parameters[6] = (System::Object^)(u_bl);
			parameters[7] = (System::Object^)(v_bl);
			parameters[8] = (System::Object^)(x_br);
			parameters[9] = (System::Object^)(y_br);
			parameters[10] = (System::Object^)(u_br);
			parameters[11] = (System::Object^)(v_br);
			parameters[12] = (System::Object^)(x_tr);
			parameters[13] = (System::Object^)(y_tr);
			parameters[14] = (System::Object^)(u_tr);
			parameters[15] = (System::Object^)(v_tr);
			parameters[16] = (System::Object^)(colR);
			parameters[17] = (System::Object^)(colG);
			parameters[18] = (System::Object^)(colB);
			parameters[19] = (System::Object^)(colA);
			parameters[20] = (System::Object^)((int)materialRes);
			parameters[21] = (System::Object^)(layer);
		
			Horde3DCall::RegisterFunctionCall("showOverlay", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnShowOverlay(x_tl, y_tl, u_tl, v_tl, x_bl, y_bl, u_bl, v_bl, x_br, y_br, u_br, v_br, x_tr, y_tr, u_tr, v_tr, colR, colG, colB, colA, (int)materialRes, layer);
		
		}
		
		void ClearOverlays()
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			h3dClearOverlays();
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			System::Object^ result = nullptr;
			array<System::Object^>^ parameters = nullptr;
		
			Horde3DCall::RegisterFunctionCall("clearOverlays", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnClearOverlays();
		
		}
		
		int GetResourceType(ResHandle res)
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			int returnValue = h3dGetResourceType(res);
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			System::Object^ result = (System::Object^)(returnValue);
			array<System::Object^>^ parameters = gcnew array<System::Object^>(1);
		
			parameters[0] = (System::Object^)((int)res);
		
			Horde3DCall::RegisterFunctionCall("getResourceType", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnGetResourceType(returnValue, (int)res);
		
			return returnValue;
		}
		
		const char* GetResourceName(ResHandle res)
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			const char* returnValue = h3dGetResourceName(res);
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			System::Object^ result = (System::Object^)(gcnew System::String(returnValue));
			array<System::Object^>^ parameters = gcnew array<System::Object^>(1);
		
			parameters[0] = (System::Object^)((int)res);
		
			Horde3DCall::RegisterFunctionCall("getResourceName", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnGetResourceName(gcnew System::String(returnValue), (int)res);
		
			return returnValue;
		}
		
		ResHandle GetNextResource(int type, ResHandle start)
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			ResHandle returnValue = h3dGetNextResource(type, start);
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			System::Object^ result = (System::Object^)((int)returnValue);
			array<System::Object^>^ parameters = gcnew array<System::Object^>(2);
		
			parameters[0] = (System::Object^)(type);
			parameters[1] = (System::Object^)((int)start);
		
			Horde3DCall::RegisterFunctionCall("getNextResource", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnGetNextResource((int)returnValue, type, (int)start);
		
			return returnValue;
		}
		
		ResHandle FindResource(int type, const char* name)
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			ResHandle returnValue = h3dFindResource(type, name);
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			System::Object^ result = (System::Object^)((int)returnValue);
			array<System::Object^>^ parameters = gcnew array<System::Object^>(2);
		
			parameters[0] = (System::Object^)(type);
			parameters[1] = (System::Object^)(gcnew System::String(name));
		
			Horde3DCall::RegisterFunctionCall("findResource", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnFindResource((int)returnValue, type, gcnew System::String(name));
		
			return returnValue;
		}
		
		ResHandle AddResource(int type, const char* name, int flags)
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			ResHandle returnValue = h3dAddResource(type, name, flags);
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			System::Object^ result = (System::Object^)((int)returnValue);
			array<System::Object^>^ parameters = gcnew array<System::Object^>(3);
		
			parameters[0] = (System::Object^)(type);
			parameters[1] = (System::Object^)(gcnew System::String(name));
			parameters[2] = (System::Object^)(flags);
		
			Horde3DCall::RegisterFunctionCall("addResource", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnAddResource((int)returnValue, type, gcnew System::String(name), flags);
		
			return returnValue;
		}
		
		ResHandle CloneResource(ResHandle sourceRes, const char* name)
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			ResHandle returnValue = h3dCloneResource(sourceRes, name);
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			System::Object^ result = (System::Object^)((int)returnValue);
			array<System::Object^>^ parameters = gcnew array<System::Object^>(2);
		
			parameters[0] = (System::Object^)((int)sourceRes);
			parameters[1] = (System::Object^)(gcnew System::String(name));
		
			Horde3DCall::RegisterFunctionCall("cloneResource", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnCloneResource((int)returnValue, (int)sourceRes, gcnew System::String(name));
		
			return returnValue;
		}
		
		int RemoveResource(ResHandle res)
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			int returnValue = h3dRemoveResource(res);
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			System::Object^ result = (System::Object^)(returnValue);
			array<System::Object^>^ parameters = gcnew array<System::Object^>(1);
		
			parameters[0] = (System::Object^)((int)res);
		
			Horde3DCall::RegisterFunctionCall("removeResource", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnRemoveResource(returnValue, (int)res);
		
			return returnValue;
		}
		
		bool IsResourceLoaded(ResHandle res)
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			bool returnValue = h3dIsResourceLoaded(res);
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			System::Object^ result = (System::Object^)(returnValue);
			array<System::Object^>^ parameters = gcnew array<System::Object^>(1);
		
			parameters[0] = (System::Object^)((int)res);
		
			Horde3DCall::RegisterFunctionCall("isResourceLoaded", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnIsResourceLoaded(returnValue, (int)res);
		
			return returnValue;
		}
		
		bool LoadResource(ResHandle res, const char* data, int size)
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			bool returnValue = h3dLoadResource(res, data, size);
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			System::Object^ result = (System::Object^)(returnValue);
			array<System::Object^>^ parameters = gcnew array<System::Object^>(3);
		
			parameters[0] = (System::Object^)((int)res);
			parameters[1] = (System::Object^)(gcnew System::String(data));
			parameters[2] = (System::Object^)(size);
		
			Horde3DCall::RegisterFunctionCall("loadResource", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnLoadResource(returnValue, (int)res, gcnew System::String(data), size);
		
			return returnValue;
		}
		
		bool UnloadResource(ResHandle res)
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			bool returnValue = h3dUnloadResource(res);
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			System::Object^ result = (System::Object^)(returnValue);
			array<System::Object^>^ parameters = gcnew array<System::Object^>(1);
		
			parameters[0] = (System::Object^)((int)res);
		
			Horde3DCall::RegisterFunctionCall("unloadResource", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnUnloadResource(returnValue, (int)res);
		
			return returnValue;
		}
		
		int GetResourceParami(ResHandle res, int param)
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			int returnValue = h3dGetResourceParami(res, param);
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			System::Object^ result = (System::Object^)(returnValue);
			array<System::Object^>^ parameters = gcnew array<System::Object^>(2);
		
			parameters[0] = (System::Object^)((int)res);
			parameters[1] = (System::Object^)(param);
		
			Horde3DCall::RegisterFunctionCall("getResourceParami", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnGetResourceParami(returnValue, (int)res, param);
		
			return returnValue;
		}
		
		bool SetResourceParami(ResHandle res, int param, int value)
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			bool returnValue = h3dSetResourceParami(res, param, value);
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			System::Object^ result = (System::Object^)(returnValue);
			array<System::Object^>^ parameters = gcnew array<System::Object^>(3);
		
			parameters[0] = (System::Object^)((int)res);
			parameters[1] = (System::Object^)(param);
			parameters[2] = (System::Object^)(value);
		
			Horde3DCall::RegisterFunctionCall("setResourceParami", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnSetResourceParami(returnValue, (int)res, param, value);
		
			return returnValue;
		}
		
		float GetResourceParamf(ResHandle res, int param)
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			float returnValue = h3dGetResourceParamf(res, param);
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			System::Object^ result = (System::Object^)(returnValue);
			array<System::Object^>^ parameters = gcnew array<System::Object^>(2);
		
			parameters[0] = (System::Object^)((int)res);
			parameters[1] = (System::Object^)(param);
		
			Horde3DCall::RegisterFunctionCall("getResourceParamf", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnGetResourceParamf(returnValue, (int)res, param);
		
			return returnValue;
		}
		
		bool SetResourceParamf(ResHandle res, int param, float value)
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			bool returnValue = h3dSetResourceParamf(res, param, value);
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			System::Object^ result = (System::Object^)(returnValue);
			array<System::Object^>^ parameters = gcnew array<System::Object^>(3);
		
			parameters[0] = (System::Object^)((int)res);
			parameters[1] = (System::Object^)(param);
			parameters[2] = (System::Object^)(value);
		
			Horde3DCall::RegisterFunctionCall("setResourceParamf", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnSetResourceParamf(returnValue, (int)res, param, value);
		
			return returnValue;
		}
		
		const char* GetResourceParamstr(ResHandle res, int param)
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			const char* returnValue = h3dGetResourceParamstr(res, param);
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			System::Object^ result = (System::Object^)(gcnew System::String(returnValue));
			array<System::Object^>^ parameters = gcnew array<System::Object^>(2);
		
			parameters[0] = (System::Object^)((int)res);
			parameters[1] = (System::Object^)(param);
		
			Horde3DCall::RegisterFunctionCall("getResourceParamstr", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnGetResourceParamstr(gcnew System::String(returnValue), (int)res, param);
		
			return returnValue;
		}
		
		bool SetResourceParamstr(ResHandle res, int param, const char* value)
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			bool returnValue = h3dSetResourceParamstr(res, param, value);
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			System::Object^ result = (System::Object^)(returnValue);
			array<System::Object^>^ parameters = gcnew array<System::Object^>(3);
		
			parameters[0] = (System::Object^)((int)res);
			parameters[1] = (System::Object^)(param);
			parameters[2] = (System::Object^)(gcnew System::String(value));
		
			Horde3DCall::RegisterFunctionCall("setResourceParamstr", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnSetResourceParamstr(returnValue, (int)res, param, gcnew System::String(value));
		
			return returnValue;
		}
		
		const void* GetResourceData(ResHandle res, int param)
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			const void* returnValue = h3dGetResourceData(res, param);
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			// Converts the value of 'returnValue' and stores it in the .NET variable '__returnValue'.
			// The type of the pointer data cannot be known without the context of the function call.
System::IntPtr __returnValue((void*)returnValue);
			// Done converting 'returnValue'.
		
			System::Object^ result = (System::Object^)(__returnValue);
			array<System::Object^>^ parameters = gcnew array<System::Object^>(2);
		
			parameters[0] = (System::Object^)((int)res);
			parameters[1] = (System::Object^)(param);
		
			Horde3DCall::RegisterFunctionCall("getResourceData", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnGetResourceData(__returnValue, (int)res, param);
		
			return returnValue;
		}
		
		bool UpdateResourceData(ResHandle res, int param, const void* data, int size)
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			bool returnValue = h3dUpdateResourceData(res, param, data, size);
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			// Converts the value of 'data' and stores it in the .NET variable '__data'.
			// The type of the pointer data cannot be known without the context of the function call.
System::IntPtr __data((void*)data);
			// Done converting 'data'.
		
			System::Object^ result = (System::Object^)(returnValue);
			array<System::Object^>^ parameters = gcnew array<System::Object^>(4);
		
			parameters[0] = (System::Object^)((int)res);
			parameters[1] = (System::Object^)(param);
			parameters[2] = (System::Object^)(__data);
			parameters[3] = (System::Object^)(size);
		
			Horde3DCall::RegisterFunctionCall("updateResourceData", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnUpdateResourceData(returnValue, (int)res, param, __data, size);
		
			return returnValue;
		}
		
		ResHandle QueryUnloadedResource(int index)
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			ResHandle returnValue = h3dQueryUnloadedResource(index);
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			System::Object^ result = (System::Object^)((int)returnValue);
			array<System::Object^>^ parameters = gcnew array<System::Object^>(1);
		
			parameters[0] = (System::Object^)(index);
		
			Horde3DCall::RegisterFunctionCall("queryUnloadedResource", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnQueryUnloadedResource((int)returnValue, index);
		
			return returnValue;
		}
		
		void ReleaseUnusedResources()
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			h3dReleaseUnusedResources();
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			System::Object^ result = nullptr;
			array<System::Object^>^ parameters = nullptr;
		
			Horde3DCall::RegisterFunctionCall("releaseUnusedResources", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnReleaseUnusedResources();
		
		}
		
		ResHandle CreateTexture2D(const char* name, int flags, int width, int height, bool renderable)
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			ResHandle returnValue = h3dCreateTexture2D(name, flags, width, height, renderable);
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			System::Object^ result = (System::Object^)((int)returnValue);
			array<System::Object^>^ parameters = gcnew array<System::Object^>(5);
		
			parameters[0] = (System::Object^)(gcnew System::String(name));
			parameters[1] = (System::Object^)(flags);
			parameters[2] = (System::Object^)(width);
			parameters[3] = (System::Object^)(height);
			parameters[4] = (System::Object^)(renderable);
		
			Horde3DCall::RegisterFunctionCall("createTexture2D", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnCreateTexture2D((int)returnValue, gcnew System::String(name), flags, width, height, renderable);
		
			return returnValue;
		}
		
		void SetShaderPreambles(const char* vertPreamble, const char* fragPreamble)
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			h3dSetShaderPreambles(vertPreamble, fragPreamble);
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			System::Object^ result = nullptr;
			array<System::Object^>^ parameters = gcnew array<System::Object^>(2);
		
			parameters[0] = (System::Object^)(gcnew System::String(vertPreamble));
			parameters[1] = (System::Object^)(gcnew System::String(fragPreamble));
		
			Horde3DCall::RegisterFunctionCall("setShaderPreambles", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnSetShaderPreambles(gcnew System::String(vertPreamble), gcnew System::String(fragPreamble));
		
		}
		
		bool SetMaterialUniform(ResHandle materialRes, const char* name, float a, float b, float c, float d)
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			bool returnValue = h3dSetMaterialUniform(materialRes, name, a, b, c, d);
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			System::Object^ result = (System::Object^)(returnValue);
			array<System::Object^>^ parameters = gcnew array<System::Object^>(6);
		
			parameters[0] = (System::Object^)((int)materialRes);
			parameters[1] = (System::Object^)(gcnew System::String(name));
			parameters[2] = (System::Object^)(a);
			parameters[3] = (System::Object^)(b);
			parameters[4] = (System::Object^)(c);
			parameters[5] = (System::Object^)(d);
		
			Horde3DCall::RegisterFunctionCall("setMaterialUniform", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnSetMaterialUniform(returnValue, (int)materialRes, gcnew System::String(name), a, b, c, d);
		
			return returnValue;
		}
		
		bool SetPipelineStageActivation(ResHandle pipelineRes, const char* stageName, bool enabled)
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			bool returnValue = h3dSetPipelineStageActivation(pipelineRes, stageName, enabled);
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			System::Object^ result = (System::Object^)(returnValue);
			array<System::Object^>^ parameters = gcnew array<System::Object^>(3);
		
			parameters[0] = (System::Object^)((int)pipelineRes);
			parameters[1] = (System::Object^)(gcnew System::String(stageName));
			parameters[2] = (System::Object^)(enabled);
		
			Horde3DCall::RegisterFunctionCall("setPipelineStageActivation", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnSetPipelineStageActivation(returnValue, (int)pipelineRes, gcnew System::String(stageName), enabled);
		
			return returnValue;
		}
		
		bool GetPipelineRenderTargetData(ResHandle pipelineRes, const char* targetName, int bufIndex, int* width, int* height, int* compCount, float* dataBuffer, int bufferSize)
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			bool returnValue = h3dGetPipelineRenderTargetData(pipelineRes, targetName, bufIndex, width, height, compCount, dataBuffer, bufferSize);
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			// Converts the value of 'dataBuffer' and stores it in the .NET variable '__dataBuffer'.
			array<System::Single>^ __dataBuffer = nullptr;
// We can only copy the data if we know the length of the array and if the dataBuffer is not null.
if (width != 0 && height != 0 && compCount != 0 && dataBuffer != 0)
{
	int size = *width * *height * *compCount;
	__dataBuffer = gcnew array<System::Single>(size);
	for (int i = 0; i < size; ++i)
		__dataBuffer[i] = dataBuffer[i];
}
			// Done converting 'dataBuffer'.
		
			System::Object^ result = (System::Object^)(returnValue);
			array<System::Object^>^ parameters = gcnew array<System::Object^>(8);
		
			parameters[0] = (System::Object^)((int)pipelineRes);
			parameters[1] = (System::Object^)(gcnew System::String(targetName));
			parameters[2] = (System::Object^)(bufIndex);
			parameters[3] = (System::Object^)(width == 0 ? 0 : *width);
			parameters[4] = (System::Object^)(height == 0 ? 0 : *height);
			parameters[5] = (System::Object^)(compCount == 0 ? 0 : *compCount);
			parameters[6] = (System::Object^)(__dataBuffer);
			parameters[7] = (System::Object^)(bufferSize);
		
			Horde3DCall::RegisterFunctionCall("getPipelineRenderTargetData", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnGetPipelineRenderTargetData(returnValue, (int)pipelineRes, gcnew System::String(targetName), bufIndex, width == 0 ? 0 : *width, height == 0 ? 0 : *height, compCount == 0 ? 0 : *compCount, __dataBuffer, bufferSize);
		
			return returnValue;
		}
		
		int GetNodeType(NodeHandle node)
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			int returnValue = h3dGetNodeType(node);
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			System::Object^ result = (System::Object^)(returnValue);
			array<System::Object^>^ parameters = gcnew array<System::Object^>(1);
		
			parameters[0] = (System::Object^)((int)node);
		
			Horde3DCall::RegisterFunctionCall("getNodeType", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnGetNodeType(returnValue, (int)node);
		
			return returnValue;
		}
		
		NodeHandle GetNodeParent(NodeHandle node)
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			NodeHandle returnValue = h3dGetNodeParent(node);
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			System::Object^ result = (System::Object^)((int)returnValue);
			array<System::Object^>^ parameters = gcnew array<System::Object^>(1);
		
			parameters[0] = (System::Object^)((int)node);
		
			Horde3DCall::RegisterFunctionCall("getNodeParent", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnGetNodeParent((int)returnValue, (int)node);
		
			return returnValue;
		}
		
		bool SetNodeParent(NodeHandle node, NodeHandle parent)
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			bool returnValue = h3dSetNodeParent(node, parent);
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			System::Object^ result = (System::Object^)(returnValue);
			array<System::Object^>^ parameters = gcnew array<System::Object^>(2);
		
			parameters[0] = (System::Object^)((int)node);
			parameters[1] = (System::Object^)((int)parent);
		
			Horde3DCall::RegisterFunctionCall("setNodeParent", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnSetNodeParent(returnValue, (int)node, (int)parent);
		
			return returnValue;
		}
		
		NodeHandle GetNodeChild(NodeHandle node, int index)
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			NodeHandle returnValue = h3dGetNodeChild(node, index);
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			System::Object^ result = (System::Object^)((int)returnValue);
			array<System::Object^>^ parameters = gcnew array<System::Object^>(2);
		
			parameters[0] = (System::Object^)((int)node);
			parameters[1] = (System::Object^)(index);
		
			Horde3DCall::RegisterFunctionCall("getNodeChild", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnGetNodeChild((int)returnValue, (int)node, index);
		
			return returnValue;
		}
		
		NodeHandle AddNodes(NodeHandle parent, ResHandle sceneGraphRes)
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			NodeHandle returnValue = h3dAddNodes(parent, sceneGraphRes);
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			System::Object^ result = (System::Object^)((int)returnValue);
			array<System::Object^>^ parameters = gcnew array<System::Object^>(2);
		
			parameters[0] = (System::Object^)((int)parent);
			parameters[1] = (System::Object^)((int)sceneGraphRes);
		
			Horde3DCall::RegisterFunctionCall("addNodes", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnAddNodes((int)returnValue, (int)parent, (int)sceneGraphRes);
		
			return returnValue;
		}
		
		bool RemoveNode(NodeHandle node)
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			bool returnValue = h3dRemoveNode(node);
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			System::Object^ result = (System::Object^)(returnValue);
			array<System::Object^>^ parameters = gcnew array<System::Object^>(1);
		
			parameters[0] = (System::Object^)((int)node);
		
			Horde3DCall::RegisterFunctionCall("removeNode", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnRemoveNode(returnValue, (int)node);
		
			return returnValue;
		}
		
		bool SetNodeActivation(NodeHandle node, bool active)
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			bool returnValue = h3dSetNodeActivation(node, active);
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			System::Object^ result = (System::Object^)(returnValue);
			array<System::Object^>^ parameters = gcnew array<System::Object^>(2);
		
			parameters[0] = (System::Object^)((int)node);
			parameters[1] = (System::Object^)(active);
		
			Horde3DCall::RegisterFunctionCall("setNodeActivation", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnSetNodeActivation(returnValue, (int)node, active);
		
			return returnValue;
		}
		
		bool CheckNodeTransformFlag(NodeHandle node, bool reset)
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			bool returnValue = h3dCheckNodeTransformFlag(node, reset);
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			System::Object^ result = (System::Object^)(returnValue);
			array<System::Object^>^ parameters = gcnew array<System::Object^>(2);
		
			parameters[0] = (System::Object^)((int)node);
			parameters[1] = (System::Object^)(reset);
		
			Horde3DCall::RegisterFunctionCall("checkNodeTransformFlag", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnCheckNodeTransformFlag(returnValue, (int)node, reset);
		
			return returnValue;
		}
		
		bool GetNodeTransform(NodeHandle node, float* tx, float* ty, float* tz, float* rx, float* ry, float* rz, float* sx, float* sy, float* sz)
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			bool returnValue = h3dGetNodeTransform(node, tx, ty, tz, rx, ry, rz, sx, sy, sz);
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			System::Object^ result = (System::Object^)(returnValue);
			array<System::Object^>^ parameters = gcnew array<System::Object^>(10);
		
			parameters[0] = (System::Object^)((int)node);
			parameters[1] = (System::Object^)(tx == 0 ? 0 : *tx);
			parameters[2] = (System::Object^)(ty == 0 ? 0 : *ty);
			parameters[3] = (System::Object^)(tz == 0 ? 0 : *tz);
			parameters[4] = (System::Object^)(rx == 0 ? 0 : *rx);
			parameters[5] = (System::Object^)(ry == 0 ? 0 : *ry);
			parameters[6] = (System::Object^)(rz == 0 ? 0 : *rz);
			parameters[7] = (System::Object^)(sx == 0 ? 0 : *sx);
			parameters[8] = (System::Object^)(sy == 0 ? 0 : *sy);
			parameters[9] = (System::Object^)(sz == 0 ? 0 : *sz);
		
			Horde3DCall::RegisterFunctionCall("getNodeTransform", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnGetNodeTransform(returnValue, (int)node, tx == 0 ? 0 : *tx, ty == 0 ? 0 : *ty, tz == 0 ? 0 : *tz, rx == 0 ? 0 : *rx, ry == 0 ? 0 : *ry, rz == 0 ? 0 : *rz, sx == 0 ? 0 : *sx, sy == 0 ? 0 : *sy, sz == 0 ? 0 : *sz);
		
			return returnValue;
		}
		
		bool SetNodeTransform(NodeHandle node, float tx, float ty, float tz, float rx, float ry, float rz, float sx, float sy, float sz)
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			bool returnValue = h3dSetNodeTransform(node, tx, ty, tz, rx, ry, rz, sx, sy, sz);
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			System::Object^ result = (System::Object^)(returnValue);
			array<System::Object^>^ parameters = gcnew array<System::Object^>(10);
		
			parameters[0] = (System::Object^)((int)node);
			parameters[1] = (System::Object^)(tx);
			parameters[2] = (System::Object^)(ty);
			parameters[3] = (System::Object^)(tz);
			parameters[4] = (System::Object^)(rx);
			parameters[5] = (System::Object^)(ry);
			parameters[6] = (System::Object^)(rz);
			parameters[7] = (System::Object^)(sx);
			parameters[8] = (System::Object^)(sy);
			parameters[9] = (System::Object^)(sz);
		
			Horde3DCall::RegisterFunctionCall("setNodeTransform", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnSetNodeTransform(returnValue, (int)node, tx, ty, tz, rx, ry, rz, sx, sy, sz);
		
			return returnValue;
		}
		
		bool GetNodeTransformMatrices(NodeHandle node, const float* * relMat, const float* * absMat)
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			bool returnValue = h3dGetNodeTransformMatrices(node, relMat, absMat);
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			// Converts the value of 'relMat' and stores it in the .NET variable '__relMat'.
			array<System::Single>^ __relMat = nullptr;
if (relMat != 0)
{
	__relMat = gcnew array<System::Single>(16);
	for (int i = 0; i < 16; ++i)
		__relMat[i] = (*relMat)[i];
}
			// Done converting 'relMat'.
		
			// Converts the value of 'absMat' and stores it in the .NET variable '__absMat'.
			array<System::Single>^ __absMat = nullptr;
if (absMat != 0)
{
	__absMat = gcnew array<System::Single>(16);
	for (int i = 0; i < 16; ++i)
		__absMat[i] = (*absMat)[i];
}
			// Done converting 'absMat'.
		
			System::Object^ result = (System::Object^)(returnValue);
			array<System::Object^>^ parameters = gcnew array<System::Object^>(3);
		
			parameters[0] = (System::Object^)((int)node);
			parameters[1] = (System::Object^)(__relMat);
			parameters[2] = (System::Object^)(__absMat);
		
			Horde3DCall::RegisterFunctionCall("getNodeTransformMatrices", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnGetNodeTransformMatrices(returnValue, (int)node, __relMat, __absMat);
		
			return returnValue;
		}
		
		bool SetNodeTransformMatrix(NodeHandle node, const float* mat4x4)
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			bool returnValue = h3dSetNodeTransformMatrix(node, mat4x4);
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			// Converts the value of 'mat4x4' and stores it in the .NET variable '__mat4x4'.
			array<System::Single>^ __mat4x4 = gcnew array<System::Single>(16);
for (int i = 0; i < 16; ++i)
	__mat4x4[i] = mat4x4[i];
			// Done converting 'mat4x4'.
		
			System::Object^ result = (System::Object^)(returnValue);
			array<System::Object^>^ parameters = gcnew array<System::Object^>(2);
		
			parameters[0] = (System::Object^)((int)node);
			parameters[1] = (System::Object^)(__mat4x4);
		
			Horde3DCall::RegisterFunctionCall("setNodeTransformMatrix", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnSetNodeTransformMatrix(returnValue, (int)node, __mat4x4);
		
			return returnValue;
		}
		
		float GetNodeParamf(NodeHandle node, int param)
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			float returnValue = h3dGetNodeParamf(node, param);
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			System::Object^ result = (System::Object^)(returnValue);
			array<System::Object^>^ parameters = gcnew array<System::Object^>(2);
		
			parameters[0] = (System::Object^)((int)node);
			parameters[1] = (System::Object^)(param);
		
			Horde3DCall::RegisterFunctionCall("getNodeParamf", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnGetNodeParamf(returnValue, (int)node, param);
		
			return returnValue;
		}
		
		bool SetNodeParamf(NodeHandle node, int param, float value)
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			bool returnValue = h3dSetNodeParamf(node, param, value);
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			System::Object^ result = (System::Object^)(returnValue);
			array<System::Object^>^ parameters = gcnew array<System::Object^>(3);
		
			parameters[0] = (System::Object^)((int)node);
			parameters[1] = (System::Object^)(param);
			parameters[2] = (System::Object^)(value);
		
			Horde3DCall::RegisterFunctionCall("setNodeParamf", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnSetNodeParamf(returnValue, (int)node, param, value);
		
			return returnValue;
		}
		
		int GetNodeParami(NodeHandle node, int param)
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			int returnValue = h3dGetNodeParami(node, param);
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			System::Object^ result = (System::Object^)(returnValue);
			array<System::Object^>^ parameters = gcnew array<System::Object^>(2);
		
			parameters[0] = (System::Object^)((int)node);
			parameters[1] = (System::Object^)(param);
		
			Horde3DCall::RegisterFunctionCall("getNodeParami", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnGetNodeParami(returnValue, (int)node, param);
		
			return returnValue;
		}
		
		bool SetNodeParami(NodeHandle node, int param, int value)
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			bool returnValue = h3dSetNodeParami(node, param, value);
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			System::Object^ result = (System::Object^)(returnValue);
			array<System::Object^>^ parameters = gcnew array<System::Object^>(3);
		
			parameters[0] = (System::Object^)((int)node);
			parameters[1] = (System::Object^)(param);
			parameters[2] = (System::Object^)(value);
		
			Horde3DCall::RegisterFunctionCall("setNodeParami", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnSetNodeParami(returnValue, (int)node, param, value);
		
			return returnValue;
		}
		
		const char* GetNodeParamstr(NodeHandle node, int param)
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			const char* returnValue = h3dGetNodeParamstr(node, param);
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			System::Object^ result = (System::Object^)(gcnew System::String(returnValue));
			array<System::Object^>^ parameters = gcnew array<System::Object^>(2);
		
			parameters[0] = (System::Object^)((int)node);
			parameters[1] = (System::Object^)(param);
		
			Horde3DCall::RegisterFunctionCall("getNodeParamstr", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnGetNodeParamstr(gcnew System::String(returnValue), (int)node, param);
		
			return returnValue;
		}
		
		bool SetNodeParamstr(NodeHandle node, int param, const char* value)
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			bool returnValue = h3dSetNodeParamstr(node, param, value);
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			System::Object^ result = (System::Object^)(returnValue);
			array<System::Object^>^ parameters = gcnew array<System::Object^>(3);
		
			parameters[0] = (System::Object^)((int)node);
			parameters[1] = (System::Object^)(param);
			parameters[2] = (System::Object^)(gcnew System::String(value));
		
			Horde3DCall::RegisterFunctionCall("setNodeParamstr", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnSetNodeParamstr(returnValue, (int)node, param, gcnew System::String(value));
		
			return returnValue;
		}
		
		bool GetNodeAABB(NodeHandle node, float* minX, float* minY, float* minZ, float* maxX, float* maxY, float* maxZ)
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			bool returnValue = h3dGetNodeAABB(node, minX, minY, minZ, maxX, maxY, maxZ);
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			System::Object^ result = (System::Object^)(returnValue);
			array<System::Object^>^ parameters = gcnew array<System::Object^>(7);
		
			parameters[0] = (System::Object^)((int)node);
			parameters[1] = (System::Object^)(minX == 0 ? 0 : *minX);
			parameters[2] = (System::Object^)(minY == 0 ? 0 : *minY);
			parameters[3] = (System::Object^)(minZ == 0 ? 0 : *minZ);
			parameters[4] = (System::Object^)(maxX == 0 ? 0 : *maxX);
			parameters[5] = (System::Object^)(maxY == 0 ? 0 : *maxY);
			parameters[6] = (System::Object^)(maxZ == 0 ? 0 : *maxZ);
		
			Horde3DCall::RegisterFunctionCall("getNodeAABB", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnGetNodeAABB(returnValue, (int)node, minX == 0 ? 0 : *minX, minY == 0 ? 0 : *minY, minZ == 0 ? 0 : *minZ, maxX == 0 ? 0 : *maxX, maxY == 0 ? 0 : *maxY, maxZ == 0 ? 0 : *maxZ);
		
			return returnValue;
		}
		
		int FindNodes(NodeHandle startNode, const char* name, int type)
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			int returnValue = h3dFindNodes(startNode, name, type);
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			System::Object^ result = (System::Object^)(returnValue);
			array<System::Object^>^ parameters = gcnew array<System::Object^>(3);
		
			parameters[0] = (System::Object^)((int)startNode);
			parameters[1] = (System::Object^)(gcnew System::String(name));
			parameters[2] = (System::Object^)(type);
		
			Horde3DCall::RegisterFunctionCall("findNodes", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnFindNodes(returnValue, (int)startNode, gcnew System::String(name), type);
		
			return returnValue;
		}
		
		NodeHandle GetNodeFindResult(int index)
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			NodeHandle returnValue = h3dGetNodeFindResult(index);
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			System::Object^ result = (System::Object^)((int)returnValue);
			array<System::Object^>^ parameters = gcnew array<System::Object^>(1);
		
			parameters[0] = (System::Object^)(index);
		
			Horde3DCall::RegisterFunctionCall("getNodeFindResult", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnGetNodeFindResult((int)returnValue, index);
		
			return returnValue;
		}
		
		int CastRay(NodeHandle node, float ox, float oy, float oz, float dx, float dy, float dz, int numNearest)
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			int returnValue = h3dCastRay(node, ox, oy, oz, dx, dy, dz, numNearest);
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			System::Object^ result = (System::Object^)(returnValue);
			array<System::Object^>^ parameters = gcnew array<System::Object^>(8);
		
			parameters[0] = (System::Object^)((int)node);
			parameters[1] = (System::Object^)(ox);
			parameters[2] = (System::Object^)(oy);
			parameters[3] = (System::Object^)(oz);
			parameters[4] = (System::Object^)(dx);
			parameters[5] = (System::Object^)(dy);
			parameters[6] = (System::Object^)(dz);
			parameters[7] = (System::Object^)(numNearest);
		
			Horde3DCall::RegisterFunctionCall("castRay", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnCastRay(returnValue, (int)node, ox, oy, oz, dx, dy, dz, numNearest);
		
			return returnValue;
		}
		
		bool GetCastRayResult(int index, NodeHandle* node, float* distance, float* intersection)
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			bool returnValue = h3dGetCastRayResult(index, node, distance, intersection);
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			System::Object^ result = (System::Object^)(returnValue);
			array<System::Object^>^ parameters = gcnew array<System::Object^>(4);
		
			parameters[0] = (System::Object^)(index);
			parameters[1] = (System::Object^)(node == 0 ? 0 : (int)(*node));
			parameters[2] = (System::Object^)(distance == 0 ? 0 : *distance);
			parameters[3] = (System::Object^)(intersection == 0 ? 0 : *intersection);
		
			Horde3DCall::RegisterFunctionCall("getCastRayResult", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnGetCastRayResult(returnValue, index, node == 0 ? 0 : (int)(*node), distance == 0 ? 0 : *distance, intersection == 0 ? 0 : *intersection);
		
			return returnValue;
		}
		
		int CheckNodeVisibility(NodeHandle node, NodeHandle cameraNode, bool checkOcclusion, bool calcLod)
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			int returnValue = h3dCheckNodeVisibility(node, cameraNode, checkOcclusion, calcLod);
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			System::Object^ result = (System::Object^)(returnValue);
			array<System::Object^>^ parameters = gcnew array<System::Object^>(4);
		
			parameters[0] = (System::Object^)((int)node);
			parameters[1] = (System::Object^)((int)cameraNode);
			parameters[2] = (System::Object^)(checkOcclusion);
			parameters[3] = (System::Object^)(calcLod);
		
			Horde3DCall::RegisterFunctionCall("checkNodeVisibility", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnCheckNodeVisibility(returnValue, (int)node, (int)cameraNode, checkOcclusion, calcLod);
		
			return returnValue;
		}
		
		NodeHandle AddGroupNode(NodeHandle parent, const char* name)
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			NodeHandle returnValue = h3dAddGroupNode(parent, name);
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			System::Object^ result = (System::Object^)((int)returnValue);
			array<System::Object^>^ parameters = gcnew array<System::Object^>(2);
		
			parameters[0] = (System::Object^)((int)parent);
			parameters[1] = (System::Object^)(gcnew System::String(name));
		
			Horde3DCall::RegisterFunctionCall("addGroupNode", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnAddGroupNode((int)returnValue, (int)parent, gcnew System::String(name));
		
			return returnValue;
		}
		
		NodeHandle AddModelNode(NodeHandle parent, const char* name, ResHandle geometryRes)
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			NodeHandle returnValue = h3dAddModelNode(parent, name, geometryRes);
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			System::Object^ result = (System::Object^)((int)returnValue);
			array<System::Object^>^ parameters = gcnew array<System::Object^>(3);
		
			parameters[0] = (System::Object^)((int)parent);
			parameters[1] = (System::Object^)(gcnew System::String(name));
			parameters[2] = (System::Object^)((int)geometryRes);
		
			Horde3DCall::RegisterFunctionCall("addModelNode", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnAddModelNode((int)returnValue, (int)parent, gcnew System::String(name), (int)geometryRes);
		
			return returnValue;
		}
		
		bool SetupModelAnimStage(NodeHandle modelNode, int stage, ResHandle animationRes, const char* startNode, bool additive)
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			bool returnValue = h3dSetupModelAnimStage(modelNode, stage, animationRes, startNode, additive);
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			System::Object^ result = (System::Object^)(returnValue);
			array<System::Object^>^ parameters = gcnew array<System::Object^>(5);
		
			parameters[0] = (System::Object^)((int)modelNode);
			parameters[1] = (System::Object^)(stage);
			parameters[2] = (System::Object^)((int)animationRes);
			parameters[3] = (System::Object^)(gcnew System::String(startNode));
			parameters[4] = (System::Object^)(additive);
		
			Horde3DCall::RegisterFunctionCall("setupModelAnimStage", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnSetupModelAnimStage(returnValue, (int)modelNode, stage, (int)animationRes, gcnew System::String(startNode), additive);
		
			return returnValue;
		}
		
		bool SetModelAnimParams(NodeHandle modelNode, int stage, float time, float weight)
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			bool returnValue = h3dSetModelAnimParams(modelNode, stage, time, weight);
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			System::Object^ result = (System::Object^)(returnValue);
			array<System::Object^>^ parameters = gcnew array<System::Object^>(4);
		
			parameters[0] = (System::Object^)((int)modelNode);
			parameters[1] = (System::Object^)(stage);
			parameters[2] = (System::Object^)(time);
			parameters[3] = (System::Object^)(weight);
		
			Horde3DCall::RegisterFunctionCall("setModelAnimParams", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnSetModelAnimParams(returnValue, (int)modelNode, stage, time, weight);
		
			return returnValue;
		}
		
		bool SetModelMorpher(NodeHandle modelNode, const char* target, float weight)
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			bool returnValue = h3dSetModelMorpher(modelNode, target, weight);
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			System::Object^ result = (System::Object^)(returnValue);
			array<System::Object^>^ parameters = gcnew array<System::Object^>(3);
		
			parameters[0] = (System::Object^)((int)modelNode);
			parameters[1] = (System::Object^)(gcnew System::String(target));
			parameters[2] = (System::Object^)(weight);
		
			Horde3DCall::RegisterFunctionCall("setModelMorpher", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnSetModelMorpher(returnValue, (int)modelNode, gcnew System::String(target), weight);
		
			return returnValue;
		}
		
		NodeHandle AddMeshNode(NodeHandle parent, const char* name, ResHandle materialRes, int batchStart, int batchCount, int vertRStart, int vertREnd)
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			NodeHandle returnValue = h3dAddMeshNode(parent, name, materialRes, batchStart, batchCount, vertRStart, vertREnd);
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			System::Object^ result = (System::Object^)((int)returnValue);
			array<System::Object^>^ parameters = gcnew array<System::Object^>(7);
		
			parameters[0] = (System::Object^)((int)parent);
			parameters[1] = (System::Object^)(gcnew System::String(name));
			parameters[2] = (System::Object^)((int)materialRes);
			parameters[3] = (System::Object^)(batchStart);
			parameters[4] = (System::Object^)(batchCount);
			parameters[5] = (System::Object^)(vertRStart);
			parameters[6] = (System::Object^)(vertREnd);
		
			Horde3DCall::RegisterFunctionCall("addMeshNode", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnAddMeshNode((int)returnValue, (int)parent, gcnew System::String(name), (int)materialRes, batchStart, batchCount, vertRStart, vertREnd);
		
			return returnValue;
		}
		
		NodeHandle AddJointNode(NodeHandle parent, const char* name, int jointIndex)
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			NodeHandle returnValue = h3dAddJointNode(parent, name, jointIndex);
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			System::Object^ result = (System::Object^)((int)returnValue);
			array<System::Object^>^ parameters = gcnew array<System::Object^>(3);
		
			parameters[0] = (System::Object^)((int)parent);
			parameters[1] = (System::Object^)(gcnew System::String(name));
			parameters[2] = (System::Object^)(jointIndex);
		
			Horde3DCall::RegisterFunctionCall("addJointNode", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnAddJointNode((int)returnValue, (int)parent, gcnew System::String(name), jointIndex);
		
			return returnValue;
		}
		
		NodeHandle AddLightNode(NodeHandle parent, const char* name, ResHandle materialRes, const char* lightingContext, const char* shadowContext)
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			NodeHandle returnValue = h3dAddLightNode(parent, name, materialRes, lightingContext, shadowContext);
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			System::Object^ result = (System::Object^)((int)returnValue);
			array<System::Object^>^ parameters = gcnew array<System::Object^>(5);
		
			parameters[0] = (System::Object^)((int)parent);
			parameters[1] = (System::Object^)(gcnew System::String(name));
			parameters[2] = (System::Object^)((int)materialRes);
			parameters[3] = (System::Object^)(gcnew System::String(lightingContext));
			parameters[4] = (System::Object^)(gcnew System::String(shadowContext));
		
			Horde3DCall::RegisterFunctionCall("addLightNode", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnAddLightNode((int)returnValue, (int)parent, gcnew System::String(name), (int)materialRes, gcnew System::String(lightingContext), gcnew System::String(shadowContext));
		
			return returnValue;
		}
		
		bool SetLightContexts(NodeHandle lightNode, const char* lightingContext, const char* shadowContext)
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			bool returnValue = h3dSetLightContexts(lightNode, lightingContext, shadowContext);
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			System::Object^ result = (System::Object^)(returnValue);
			array<System::Object^>^ parameters = gcnew array<System::Object^>(3);
		
			parameters[0] = (System::Object^)((int)lightNode);
			parameters[1] = (System::Object^)(gcnew System::String(lightingContext));
			parameters[2] = (System::Object^)(gcnew System::String(shadowContext));
		
			Horde3DCall::RegisterFunctionCall("setLightContexts", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnSetLightContexts(returnValue, (int)lightNode, gcnew System::String(lightingContext), gcnew System::String(shadowContext));
		
			return returnValue;
		}
		
		NodeHandle AddCameraNode(NodeHandle parent, const char* name, ResHandle pipelineRes)
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			NodeHandle returnValue = h3dAddCameraNode(parent, name, pipelineRes);
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			System::Object^ result = (System::Object^)((int)returnValue);
			array<System::Object^>^ parameters = gcnew array<System::Object^>(3);
		
			parameters[0] = (System::Object^)((int)parent);
			parameters[1] = (System::Object^)(gcnew System::String(name));
			parameters[2] = (System::Object^)((int)pipelineRes);
		
			Horde3DCall::RegisterFunctionCall("addCameraNode", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnAddCameraNode((int)returnValue, (int)parent, gcnew System::String(name), (int)pipelineRes);
		
			return returnValue;
		}
		
		bool SetupCameraView(NodeHandle cameraNode, float fov, float aspect, float nearDist, float farDist)
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			bool returnValue = h3dSetupCameraView(cameraNode, fov, aspect, nearDist, farDist);
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			System::Object^ result = (System::Object^)(returnValue);
			array<System::Object^>^ parameters = gcnew array<System::Object^>(5);
		
			parameters[0] = (System::Object^)((int)cameraNode);
			parameters[1] = (System::Object^)(fov);
			parameters[2] = (System::Object^)(aspect);
			parameters[3] = (System::Object^)(nearDist);
			parameters[4] = (System::Object^)(farDist);
		
			Horde3DCall::RegisterFunctionCall("setupCameraView", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnSetupCameraView(returnValue, (int)cameraNode, fov, aspect, nearDist, farDist);
		
			return returnValue;
		}
		
		bool GetCameraProjectionMatrix(NodeHandle cameraNode, float* projMat)
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			bool returnValue = h3dGetCameraProjectionMatrix(cameraNode, projMat);
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			// Converts the value of 'projMat' and stores it in the .NET variable '__projMat'.
			array<System::Single>^ __projMat = gcnew array<System::Single>(16);
for (int i = 0; i < 16; ++i)
	__projMat[i] = projMat[i];
			// Done converting 'projMat'.
		
			System::Object^ result = (System::Object^)(returnValue);
			array<System::Object^>^ parameters = gcnew array<System::Object^>(2);
		
			parameters[0] = (System::Object^)((int)cameraNode);
			parameters[1] = (System::Object^)(__projMat);
		
			Horde3DCall::RegisterFunctionCall("getCameraProjectionMatrix", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnGetCameraProjectionMatrix(returnValue, (int)cameraNode, __projMat);
		
			return returnValue;
		}
		
		NodeHandle AddEmitterNode(NodeHandle parent, const char* name, ResHandle materialRes, ResHandle particleEffectRes, int maxParticleCount, int respawnCount)
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			NodeHandle returnValue = h3dAddEmitterNode(parent, name, materialRes, particleEffectRes, maxParticleCount, respawnCount);
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			System::Object^ result = (System::Object^)((int)returnValue);
			array<System::Object^>^ parameters = gcnew array<System::Object^>(6);
		
			parameters[0] = (System::Object^)((int)parent);
			parameters[1] = (System::Object^)(gcnew System::String(name));
			parameters[2] = (System::Object^)((int)materialRes);
			parameters[3] = (System::Object^)((int)particleEffectRes);
			parameters[4] = (System::Object^)(maxParticleCount);
			parameters[5] = (System::Object^)(respawnCount);
		
			Horde3DCall::RegisterFunctionCall("addEmitterNode", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnAddEmitterNode((int)returnValue, (int)parent, gcnew System::String(name), (int)materialRes, (int)particleEffectRes, maxParticleCount, respawnCount);
		
			return returnValue;
		}
		
		bool AdvanceEmitterTime(NodeHandle emitterNode, float timeDelta)
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			bool returnValue = h3dAdvanceEmitterTime(emitterNode, timeDelta);
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			System::Object^ result = (System::Object^)(returnValue);
			array<System::Object^>^ parameters = gcnew array<System::Object^>(2);
		
			parameters[0] = (System::Object^)((int)emitterNode);
			parameters[1] = (System::Object^)(timeDelta);
		
			Horde3DCall::RegisterFunctionCall("advanceEmitterTime", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnAdvanceEmitterTime(returnValue, (int)emitterNode, timeDelta);
		
			return returnValue;
		}
		
		bool HasEmitterFinished(NodeHandle emitterNode)
		{
			double callTime = (double)stopwatch->ElapsedTicks;
			bool returnValue = h3dHasEmitterFinished(emitterNode);
			double endCallTime = (double)stopwatch->ElapsedTicks;
		
			System::Object^ result = (System::Object^)(returnValue);
			array<System::Object^>^ parameters = gcnew array<System::Object^>(1);
		
			parameters[0] = (System::Object^)((int)emitterNode);
		
			Horde3DCall::RegisterFunctionCall("hasEmitterFinished", callTime / (double)stopwatch->Frequency, (endCallTime - callTime) / (double)stopwatch->Frequency, result, parameters);
			Horde3DCall::OnHasEmitterFinished(returnValue, (int)emitterNode);
		
			return returnValue;
		}
		

	};

	class Horde3DNoProfilingProxy : public Horde3DProxyBase
	{
	public:
		virtual ~Horde3DNoProfilingProxy() 
		{
		}

		// Horde3D No Profiling Function Proxies
		const char* GetVersionString()
		{
			const char* returnValue = h3dGetVersionString();
			
			Horde3DCall::OnGetVersionString(gcnew System::String(returnValue));
			return returnValue;
		}
		
		bool CheckExtension(const char* extensionName)
		{
			bool returnValue = h3dCheckExtension(extensionName);
			
			Horde3DCall::OnCheckExtension(returnValue, gcnew System::String(extensionName));
			return returnValue;
		}
		
		bool Init()
		{
			bool returnValue = h3dInit();
			
			Horde3DCall::OnInit(returnValue);
			return returnValue;
		}
		
		void Release()
		{
			h3dRelease();
			
			Horde3DCall::OnRelease();
		}
		
		void SetupViewport(int x, int y, int width, int height, bool resizeBuffers)
		{
			h3dSetupViewport(x, y, width, height, resizeBuffers);
			
			Horde3DCall::OnSetupViewport(x, y, width, height, resizeBuffers);
		}
		
		bool Render(NodeHandle cameraNode)
		{
			bool returnValue = h3dRender(cameraNode);
			
			Horde3DCall::OnRender(returnValue, (int)cameraNode);
			return returnValue;
		}
		
		bool FinalizeFrame()
		{
			bool returnValue = h3dFinalizeFrame();
			
			Horde3DCall::OnFinalizeFrame(returnValue);
			return returnValue;
		}
		
		void Clear()
		{
			h3dClear();
			
			Horde3DCall::OnClear();
		}
		
		const char* GetMessage(int* level, float* time)
		{
			const char* returnValue = h3dGetMessage(level, time);
			
			Horde3DCall::OnGetMessage(gcnew System::String(returnValue), level == 0 ? 0 : *level, time == 0 ? 0 : *time);
			return returnValue;
		}
		
		float GetOption(EngineOptions::List param)
		{
			float returnValue = h3dGetOption(param);
			
			Horde3DCall::OnGetOption(returnValue, (int)param);
			return returnValue;
		}
		
		bool SetOption(EngineOptions::List param, float value)
		{
			bool returnValue = h3dSetOption(param, value);
			
			Horde3DCall::OnSetOption(returnValue, (int)param, value);
			return returnValue;
		}
		
		float GetStat(EngineStats::List param, bool reset)
		{
			float returnValue = h3dGetStat(param, reset);
			
			Horde3DCall::OnGetStat(returnValue, (int)param, reset);
			return returnValue;
		}
		
		void ShowOverlay(float x_tl, float y_tl, float u_tl, float v_tl, float x_bl, float y_bl, float u_bl, float v_bl, float x_br, float y_br, float u_br, float v_br, float x_tr, float y_tr, float u_tr, float v_tr, float colR, float colG, float colB, float colA, ResHandle materialRes, int layer)
		{
			h3dShowOverlay(x_tl, y_tl, u_tl, v_tl, x_bl, y_bl, u_bl, v_bl, x_br, y_br, u_br, v_br, x_tr, y_tr, u_tr, v_tr, colR, colG, colB, colA, materialRes, layer);
			
			Horde3DCall::OnShowOverlay(x_tl, y_tl, u_tl, v_tl, x_bl, y_bl, u_bl, v_bl, x_br, y_br, u_br, v_br, x_tr, y_tr, u_tr, v_tr, colR, colG, colB, colA, (int)materialRes, layer);
		}
		
		void ClearOverlays()
		{
			h3dClearOverlays();
			
			Horde3DCall::OnClearOverlays();
		}
		
		int GetResourceType(ResHandle res)
		{
			int returnValue = h3dGetResourceType(res);
			
			Horde3DCall::OnGetResourceType(returnValue, (int)res);
			return returnValue;
		}
		
		const char* GetResourceName(ResHandle res)
		{
			const char* returnValue = h3dGetResourceName(res);
			
			Horde3DCall::OnGetResourceName(gcnew System::String(returnValue), (int)res);
			return returnValue;
		}
		
		ResHandle GetNextResource(int type, ResHandle start)
		{
			ResHandle returnValue = h3dGetNextResource(type, start);
			
			Horde3DCall::OnGetNextResource((int)returnValue, type, (int)start);
			return returnValue;
		}
		
		ResHandle FindResource(int type, const char* name)
		{
			ResHandle returnValue = h3dFindResource(type, name);
			
			Horde3DCall::OnFindResource((int)returnValue, type, gcnew System::String(name));
			return returnValue;
		}
		
		ResHandle AddResource(int type, const char* name, int flags)
		{
			ResHandle returnValue = h3dAddResource(type, name, flags);
			
			Horde3DCall::OnAddResource((int)returnValue, type, gcnew System::String(name), flags);
			return returnValue;
		}
		
		ResHandle CloneResource(ResHandle sourceRes, const char* name)
		{
			ResHandle returnValue = h3dCloneResource(sourceRes, name);
			
			Horde3DCall::OnCloneResource((int)returnValue, (int)sourceRes, gcnew System::String(name));
			return returnValue;
		}
		
		int RemoveResource(ResHandle res)
		{
			int returnValue = h3dRemoveResource(res);
			
			Horde3DCall::OnRemoveResource(returnValue, (int)res);
			return returnValue;
		}
		
		bool IsResourceLoaded(ResHandle res)
		{
			bool returnValue = h3dIsResourceLoaded(res);
			
			Horde3DCall::OnIsResourceLoaded(returnValue, (int)res);
			return returnValue;
		}
		
		bool LoadResource(ResHandle res, const char* data, int size)
		{
			bool returnValue = h3dLoadResource(res, data, size);
			
			Horde3DCall::OnLoadResource(returnValue, (int)res, gcnew System::String(data), size);
			return returnValue;
		}
		
		bool UnloadResource(ResHandle res)
		{
			bool returnValue = h3dUnloadResource(res);
			
			Horde3DCall::OnUnloadResource(returnValue, (int)res);
			return returnValue;
		}
		
		int GetResourceParami(ResHandle res, int param)
		{
			int returnValue = h3dGetResourceParami(res, param);
			
			Horde3DCall::OnGetResourceParami(returnValue, (int)res, param);
			return returnValue;
		}
		
		bool SetResourceParami(ResHandle res, int param, int value)
		{
			bool returnValue = h3dSetResourceParami(res, param, value);
			
			Horde3DCall::OnSetResourceParami(returnValue, (int)res, param, value);
			return returnValue;
		}
		
		float GetResourceParamf(ResHandle res, int param)
		{
			float returnValue = h3dGetResourceParamf(res, param);
			
			Horde3DCall::OnGetResourceParamf(returnValue, (int)res, param);
			return returnValue;
		}
		
		bool SetResourceParamf(ResHandle res, int param, float value)
		{
			bool returnValue = h3dSetResourceParamf(res, param, value);
			
			Horde3DCall::OnSetResourceParamf(returnValue, (int)res, param, value);
			return returnValue;
		}
		
		const char* GetResourceParamstr(ResHandle res, int param)
		{
			const char* returnValue = h3dGetResourceParamstr(res, param);
			
			Horde3DCall::OnGetResourceParamstr(gcnew System::String(returnValue), (int)res, param);
			return returnValue;
		}
		
		bool SetResourceParamstr(ResHandle res, int param, const char* value)
		{
			bool returnValue = h3dSetResourceParamstr(res, param, value);
			
			Horde3DCall::OnSetResourceParamstr(returnValue, (int)res, param, gcnew System::String(value));
			return returnValue;
		}
		
		const void* GetResourceData(ResHandle res, int param)
		{
			const void* returnValue = h3dGetResourceData(res, param);
			
			// Converts the value of 'returnValue' and stores it in the .NET variable '__returnValue'.
			// The type of the pointer data cannot be known without the context of the function call.
System::IntPtr __returnValue((void*)returnValue);
			// Done converting 'returnValue'.
		
			Horde3DCall::OnGetResourceData(__returnValue, (int)res, param);
			return returnValue;
		}
		
		bool UpdateResourceData(ResHandle res, int param, const void* data, int size)
		{
			bool returnValue = h3dUpdateResourceData(res, param, data, size);
			
			// Converts the value of 'data' and stores it in the .NET variable '__data'.
			// The type of the pointer data cannot be known without the context of the function call.
System::IntPtr __data((void*)data);
			// Done converting 'data'.
		
			Horde3DCall::OnUpdateResourceData(returnValue, (int)res, param, __data, size);
			return returnValue;
		}
		
		ResHandle QueryUnloadedResource(int index)
		{
			ResHandle returnValue = h3dQueryUnloadedResource(index);
			
			Horde3DCall::OnQueryUnloadedResource((int)returnValue, index);
			return returnValue;
		}
		
		void ReleaseUnusedResources()
		{
			h3dReleaseUnusedResources();
			
			Horde3DCall::OnReleaseUnusedResources();
		}
		
		ResHandle CreateTexture2D(const char* name, int flags, int width, int height, bool renderable)
		{
			ResHandle returnValue = h3dCreateTexture2D(name, flags, width, height, renderable);
			
			Horde3DCall::OnCreateTexture2D((int)returnValue, gcnew System::String(name), flags, width, height, renderable);
			return returnValue;
		}
		
		void SetShaderPreambles(const char* vertPreamble, const char* fragPreamble)
		{
			h3dSetShaderPreambles(vertPreamble, fragPreamble);
			
			Horde3DCall::OnSetShaderPreambles(gcnew System::String(vertPreamble), gcnew System::String(fragPreamble));
		}
		
		bool SetMaterialUniform(ResHandle materialRes, const char* name, float a, float b, float c, float d)
		{
			bool returnValue = h3dSetMaterialUniform(materialRes, name, a, b, c, d);
			
			Horde3DCall::OnSetMaterialUniform(returnValue, (int)materialRes, gcnew System::String(name), a, b, c, d);
			return returnValue;
		}
		
		bool SetPipelineStageActivation(ResHandle pipelineRes, const char* stageName, bool enabled)
		{
			bool returnValue = h3dSetPipelineStageActivation(pipelineRes, stageName, enabled);
			
			Horde3DCall::OnSetPipelineStageActivation(returnValue, (int)pipelineRes, gcnew System::String(stageName), enabled);
			return returnValue;
		}
		
		bool GetPipelineRenderTargetData(ResHandle pipelineRes, const char* targetName, int bufIndex, int* width, int* height, int* compCount, float* dataBuffer, int bufferSize)
		{
			bool returnValue = h3dGetPipelineRenderTargetData(pipelineRes, targetName, bufIndex, width, height, compCount, dataBuffer, bufferSize);
			
			// Converts the value of 'dataBuffer' and stores it in the .NET variable '__dataBuffer'.
			array<System::Single>^ __dataBuffer = nullptr;
// We can only copy the data if we know the length of the array and if the dataBuffer is not null.
if (width != 0 && height != 0 && compCount != 0 && dataBuffer != 0)
{
	int size = *width * *height * *compCount;
	__dataBuffer = gcnew array<System::Single>(size);
	for (int i = 0; i < size; ++i)
		__dataBuffer[i] = dataBuffer[i];
}
			// Done converting 'dataBuffer'.
		
			Horde3DCall::OnGetPipelineRenderTargetData(returnValue, (int)pipelineRes, gcnew System::String(targetName), bufIndex, width == 0 ? 0 : *width, height == 0 ? 0 : *height, compCount == 0 ? 0 : *compCount, __dataBuffer, bufferSize);
			return returnValue;
		}
		
		int GetNodeType(NodeHandle node)
		{
			int returnValue = h3dGetNodeType(node);
			
			Horde3DCall::OnGetNodeType(returnValue, (int)node);
			return returnValue;
		}
		
		NodeHandle GetNodeParent(NodeHandle node)
		{
			NodeHandle returnValue = h3dGetNodeParent(node);
			
			Horde3DCall::OnGetNodeParent((int)returnValue, (int)node);
			return returnValue;
		}
		
		bool SetNodeParent(NodeHandle node, NodeHandle parent)
		{
			bool returnValue = h3dSetNodeParent(node, parent);
			
			Horde3DCall::OnSetNodeParent(returnValue, (int)node, (int)parent);
			return returnValue;
		}
		
		NodeHandle GetNodeChild(NodeHandle node, int index)
		{
			NodeHandle returnValue = h3dGetNodeChild(node, index);
			
			Horde3DCall::OnGetNodeChild((int)returnValue, (int)node, index);
			return returnValue;
		}
		
		NodeHandle AddNodes(NodeHandle parent, ResHandle sceneGraphRes)
		{
			NodeHandle returnValue = h3dAddNodes(parent, sceneGraphRes);
			
			Horde3DCall::OnAddNodes((int)returnValue, (int)parent, (int)sceneGraphRes);
			return returnValue;
		}
		
		bool RemoveNode(NodeHandle node)
		{
			bool returnValue = h3dRemoveNode(node);
			
			Horde3DCall::OnRemoveNode(returnValue, (int)node);
			return returnValue;
		}
		
		bool SetNodeActivation(NodeHandle node, bool active)
		{
			bool returnValue = h3dSetNodeActivation(node, active);
			
			Horde3DCall::OnSetNodeActivation(returnValue, (int)node, active);
			return returnValue;
		}
		
		bool CheckNodeTransformFlag(NodeHandle node, bool reset)
		{
			bool returnValue = h3dCheckNodeTransformFlag(node, reset);
			
			Horde3DCall::OnCheckNodeTransformFlag(returnValue, (int)node, reset);
			return returnValue;
		}
		
		bool GetNodeTransform(NodeHandle node, float* tx, float* ty, float* tz, float* rx, float* ry, float* rz, float* sx, float* sy, float* sz)
		{
			bool returnValue = h3dGetNodeTransform(node, tx, ty, tz, rx, ry, rz, sx, sy, sz);
			
			Horde3DCall::OnGetNodeTransform(returnValue, (int)node, tx == 0 ? 0 : *tx, ty == 0 ? 0 : *ty, tz == 0 ? 0 : *tz, rx == 0 ? 0 : *rx, ry == 0 ? 0 : *ry, rz == 0 ? 0 : *rz, sx == 0 ? 0 : *sx, sy == 0 ? 0 : *sy, sz == 0 ? 0 : *sz);
			return returnValue;
		}
		
		bool SetNodeTransform(NodeHandle node, float tx, float ty, float tz, float rx, float ry, float rz, float sx, float sy, float sz)
		{
			bool returnValue = h3dSetNodeTransform(node, tx, ty, tz, rx, ry, rz, sx, sy, sz);
			
			Horde3DCall::OnSetNodeTransform(returnValue, (int)node, tx, ty, tz, rx, ry, rz, sx, sy, sz);
			return returnValue;
		}
		
		bool GetNodeTransformMatrices(NodeHandle node, const float* * relMat, const float* * absMat)
		{
			bool returnValue = h3dGetNodeTransformMatrices(node, relMat, absMat);
			
			// Converts the value of 'relMat' and stores it in the .NET variable '__relMat'.
			array<System::Single>^ __relMat = nullptr;
if (relMat != 0)
{
	__relMat = gcnew array<System::Single>(16);
	for (int i = 0; i < 16; ++i)
		__relMat[i] = (*relMat)[i];
}
			// Done converting 'relMat'.
		
			// Converts the value of 'absMat' and stores it in the .NET variable '__absMat'.
			array<System::Single>^ __absMat = nullptr;
if (absMat != 0)
{
	__absMat = gcnew array<System::Single>(16);
	for (int i = 0; i < 16; ++i)
		__absMat[i] = (*absMat)[i];
}
			// Done converting 'absMat'.
		
			Horde3DCall::OnGetNodeTransformMatrices(returnValue, (int)node, __relMat, __absMat);
			return returnValue;
		}
		
		bool SetNodeTransformMatrix(NodeHandle node, const float* mat4x4)
		{
			bool returnValue = h3dSetNodeTransformMatrix(node, mat4x4);
			
			// Converts the value of 'mat4x4' and stores it in the .NET variable '__mat4x4'.
			array<System::Single>^ __mat4x4 = gcnew array<System::Single>(16);
for (int i = 0; i < 16; ++i)
	__mat4x4[i] = mat4x4[i];
			// Done converting 'mat4x4'.
		
			Horde3DCall::OnSetNodeTransformMatrix(returnValue, (int)node, __mat4x4);
			return returnValue;
		}
		
		float GetNodeParamf(NodeHandle node, int param)
		{
			float returnValue = h3dGetNodeParamf(node, param);
			
			Horde3DCall::OnGetNodeParamf(returnValue, (int)node, param);
			return returnValue;
		}
		
		bool SetNodeParamf(NodeHandle node, int param, float value)
		{
			bool returnValue = h3dSetNodeParamf(node, param, value);
			
			Horde3DCall::OnSetNodeParamf(returnValue, (int)node, param, value);
			return returnValue;
		}
		
		int GetNodeParami(NodeHandle node, int param)
		{
			int returnValue = h3dGetNodeParami(node, param);
			
			Horde3DCall::OnGetNodeParami(returnValue, (int)node, param);
			return returnValue;
		}
		
		bool SetNodeParami(NodeHandle node, int param, int value)
		{
			bool returnValue = h3dSetNodeParami(node, param, value);
			
			Horde3DCall::OnSetNodeParami(returnValue, (int)node, param, value);
			return returnValue;
		}
		
		const char* GetNodeParamstr(NodeHandle node, int param)
		{
			const char* returnValue = h3dGetNodeParamstr(node, param);
			
			Horde3DCall::OnGetNodeParamstr(gcnew System::String(returnValue), (int)node, param);
			return returnValue;
		}
		
		bool SetNodeParamstr(NodeHandle node, int param, const char* value)
		{
			bool returnValue = h3dSetNodeParamstr(node, param, value);
			
			Horde3DCall::OnSetNodeParamstr(returnValue, (int)node, param, gcnew System::String(value));
			return returnValue;
		}
		
		bool GetNodeAABB(NodeHandle node, float* minX, float* minY, float* minZ, float* maxX, float* maxY, float* maxZ)
		{
			bool returnValue = h3dGetNodeAABB(node, minX, minY, minZ, maxX, maxY, maxZ);
			
			Horde3DCall::OnGetNodeAABB(returnValue, (int)node, minX == 0 ? 0 : *minX, minY == 0 ? 0 : *minY, minZ == 0 ? 0 : *minZ, maxX == 0 ? 0 : *maxX, maxY == 0 ? 0 : *maxY, maxZ == 0 ? 0 : *maxZ);
			return returnValue;
		}
		
		int FindNodes(NodeHandle startNode, const char* name, int type)
		{
			int returnValue = h3dFindNodes(startNode, name, type);
			
			Horde3DCall::OnFindNodes(returnValue, (int)startNode, gcnew System::String(name), type);
			return returnValue;
		}
		
		NodeHandle GetNodeFindResult(int index)
		{
			NodeHandle returnValue = h3dGetNodeFindResult(index);
			
			Horde3DCall::OnGetNodeFindResult((int)returnValue, index);
			return returnValue;
		}
		
		int CastRay(NodeHandle node, float ox, float oy, float oz, float dx, float dy, float dz, int numNearest)
		{
			int returnValue = h3dCastRay(node, ox, oy, oz, dx, dy, dz, numNearest);
			
			Horde3DCall::OnCastRay(returnValue, (int)node, ox, oy, oz, dx, dy, dz, numNearest);
			return returnValue;
		}
		
		bool GetCastRayResult(int index, NodeHandle* node, float* distance, float* intersection)
		{
			bool returnValue = h3dGetCastRayResult(index, node, distance, intersection);
			
			Horde3DCall::OnGetCastRayResult(returnValue, index, node == 0 ? 0 : (int)(*node), distance == 0 ? 0 : *distance, intersection == 0 ? 0 : *intersection);
			return returnValue;
		}
		
		int CheckNodeVisibility(NodeHandle node, NodeHandle cameraNode, bool checkOcclusion, bool calcLod)
		{
			int returnValue = h3dCheckNodeVisibility(node, cameraNode, checkOcclusion, calcLod);
			
			Horde3DCall::OnCheckNodeVisibility(returnValue, (int)node, (int)cameraNode, checkOcclusion, calcLod);
			return returnValue;
		}
		
		NodeHandle AddGroupNode(NodeHandle parent, const char* name)
		{
			NodeHandle returnValue = h3dAddGroupNode(parent, name);
			
			Horde3DCall::OnAddGroupNode((int)returnValue, (int)parent, gcnew System::String(name));
			return returnValue;
		}
		
		NodeHandle AddModelNode(NodeHandle parent, const char* name, ResHandle geometryRes)
		{
			NodeHandle returnValue = h3dAddModelNode(parent, name, geometryRes);
			
			Horde3DCall::OnAddModelNode((int)returnValue, (int)parent, gcnew System::String(name), (int)geometryRes);
			return returnValue;
		}
		
		bool SetupModelAnimStage(NodeHandle modelNode, int stage, ResHandle animationRes, const char* startNode, bool additive)
		{
			bool returnValue = h3dSetupModelAnimStage(modelNode, stage, animationRes, startNode, additive);
			
			Horde3DCall::OnSetupModelAnimStage(returnValue, (int)modelNode, stage, (int)animationRes, gcnew System::String(startNode), additive);
			return returnValue;
		}
		
		bool SetModelAnimParams(NodeHandle modelNode, int stage, float time, float weight)
		{
			bool returnValue = h3dSetModelAnimParams(modelNode, stage, time, weight);
			
			Horde3DCall::OnSetModelAnimParams(returnValue, (int)modelNode, stage, time, weight);
			return returnValue;
		}
		
		bool SetModelMorpher(NodeHandle modelNode, const char* target, float weight)
		{
			bool returnValue = h3dSetModelMorpher(modelNode, target, weight);
			
			Horde3DCall::OnSetModelMorpher(returnValue, (int)modelNode, gcnew System::String(target), weight);
			return returnValue;
		}
		
		NodeHandle AddMeshNode(NodeHandle parent, const char* name, ResHandle materialRes, int batchStart, int batchCount, int vertRStart, int vertREnd)
		{
			NodeHandle returnValue = h3dAddMeshNode(parent, name, materialRes, batchStart, batchCount, vertRStart, vertREnd);
			
			Horde3DCall::OnAddMeshNode((int)returnValue, (int)parent, gcnew System::String(name), (int)materialRes, batchStart, batchCount, vertRStart, vertREnd);
			return returnValue;
		}
		
		NodeHandle AddJointNode(NodeHandle parent, const char* name, int jointIndex)
		{
			NodeHandle returnValue = h3dAddJointNode(parent, name, jointIndex);
			
			Horde3DCall::OnAddJointNode((int)returnValue, (int)parent, gcnew System::String(name), jointIndex);
			return returnValue;
		}
		
		NodeHandle AddLightNode(NodeHandle parent, const char* name, ResHandle materialRes, const char* lightingContext, const char* shadowContext)
		{
			NodeHandle returnValue = h3dAddLightNode(parent, name, materialRes, lightingContext, shadowContext);
			
			Horde3DCall::OnAddLightNode((int)returnValue, (int)parent, gcnew System::String(name), (int)materialRes, gcnew System::String(lightingContext), gcnew System::String(shadowContext));
			return returnValue;
		}
		
		bool SetLightContexts(NodeHandle lightNode, const char* lightingContext, const char* shadowContext)
		{
			bool returnValue = h3dSetLightContexts(lightNode, lightingContext, shadowContext);
			
			Horde3DCall::OnSetLightContexts(returnValue, (int)lightNode, gcnew System::String(lightingContext), gcnew System::String(shadowContext));
			return returnValue;
		}
		
		NodeHandle AddCameraNode(NodeHandle parent, const char* name, ResHandle pipelineRes)
		{
			NodeHandle returnValue = h3dAddCameraNode(parent, name, pipelineRes);
			
			Horde3DCall::OnAddCameraNode((int)returnValue, (int)parent, gcnew System::String(name), (int)pipelineRes);
			return returnValue;
		}
		
		bool SetupCameraView(NodeHandle cameraNode, float fov, float aspect, float nearDist, float farDist)
		{
			bool returnValue = h3dSetupCameraView(cameraNode, fov, aspect, nearDist, farDist);
			
			Horde3DCall::OnSetupCameraView(returnValue, (int)cameraNode, fov, aspect, nearDist, farDist);
			return returnValue;
		}
		
		bool GetCameraProjectionMatrix(NodeHandle cameraNode, float* projMat)
		{
			bool returnValue = h3dGetCameraProjectionMatrix(cameraNode, projMat);
			
			// Converts the value of 'projMat' and stores it in the .NET variable '__projMat'.
			array<System::Single>^ __projMat = gcnew array<System::Single>(16);
for (int i = 0; i < 16; ++i)
	__projMat[i] = projMat[i];
			// Done converting 'projMat'.
		
			Horde3DCall::OnGetCameraProjectionMatrix(returnValue, (int)cameraNode, __projMat);
			return returnValue;
		}
		
		NodeHandle AddEmitterNode(NodeHandle parent, const char* name, ResHandle materialRes, ResHandle particleEffectRes, int maxParticleCount, int respawnCount)
		{
			NodeHandle returnValue = h3dAddEmitterNode(parent, name, materialRes, particleEffectRes, maxParticleCount, respawnCount);
			
			Horde3DCall::OnAddEmitterNode((int)returnValue, (int)parent, gcnew System::String(name), (int)materialRes, (int)particleEffectRes, maxParticleCount, respawnCount);
			return returnValue;
		}
		
		bool AdvanceEmitterTime(NodeHandle emitterNode, float timeDelta)
		{
			bool returnValue = h3dAdvanceEmitterTime(emitterNode, timeDelta);
			
			Horde3DCall::OnAdvanceEmitterTime(returnValue, (int)emitterNode, timeDelta);
			return returnValue;
		}
		
		bool HasEmitterFinished(NodeHandle emitterNode)
		{
			bool returnValue = h3dHasEmitterFinished(emitterNode);
			
			Horde3DCall::OnHasEmitterFinished(returnValue, (int)emitterNode);
			return returnValue;
		}
		

	};

	DLL const char* getVersionString()
	{
		return g_proxyHandler.GetCurrentProxy()->GetVersionString();
	}
	
	DLL bool checkExtension(const char* extensionName)
	{
		return g_proxyHandler.GetCurrentProxy()->CheckExtension(extensionName);
	}
	
	DLL bool init()
	{
		return g_proxyHandler.GetCurrentProxy()->Init();
	}
	
	DLL void release()
	{
		g_proxyHandler.GetCurrentProxy()->Release();
	}
	
	DLL void setupViewport(int x, int y, int width, int height, bool resizeBuffers)
	{
		g_proxyHandler.GetCurrentProxy()->SetupViewport(x, y, width, height, resizeBuffers);
	}
	
	DLL bool render(NodeHandle cameraNode)
	{
		return g_proxyHandler.GetCurrentProxy()->Render(cameraNode);
	}
	
	DLL bool finalizeFrame()
	{
		return g_proxyHandler.GetCurrentProxy()->FinalizeFrame();
	}
	
	DLL void clear()
	{
		g_proxyHandler.GetCurrentProxy()->Clear();
	}
	
	DLL const char* getMessage(int* level, float* time)
	{
		return g_proxyHandler.GetCurrentProxy()->GetMessage(level, time);
	}
	
	DLL float getOption(EngineOptions::List param)
	{
		return g_proxyHandler.GetCurrentProxy()->GetOption(param);
	}
	
	DLL bool setOption(EngineOptions::List param, float value)
	{
		return g_proxyHandler.GetCurrentProxy()->SetOption(param, value);
	}
	
	DLL float getStat(EngineStats::List param, bool reset)
	{
		return g_proxyHandler.GetCurrentProxy()->GetStat(param, reset);
	}
	
	DLL void showOverlay(float x_tl, float y_tl, float u_tl, float v_tl, float x_bl, float y_bl, float u_bl, float v_bl, float x_br, float y_br, float u_br, float v_br, float x_tr, float y_tr, float u_tr, float v_tr, float colR, float colG, float colB, float colA, ResHandle materialRes, int layer)
	{
		g_proxyHandler.GetCurrentProxy()->ShowOverlay(x_tl, y_tl, u_tl, v_tl, x_bl, y_bl, u_bl, v_bl, x_br, y_br, u_br, v_br, x_tr, y_tr, u_tr, v_tr, colR, colG, colB, colA, materialRes, layer);
	}
	
	DLL void clearOverlays()
	{
		g_proxyHandler.GetCurrentProxy()->ClearOverlays();
	}
	
	DLL int getResourceType(ResHandle res)
	{
		return g_proxyHandler.GetCurrentProxy()->GetResourceType(res);
	}
	
	DLL const char* getResourceName(ResHandle res)
	{
		return g_proxyHandler.GetCurrentProxy()->GetResourceName(res);
	}
	
	DLL ResHandle getNextResource(int type, ResHandle start)
	{
		return g_proxyHandler.GetCurrentProxy()->GetNextResource(type, start);
	}
	
	DLL ResHandle findResource(int type, const char* name)
	{
		return g_proxyHandler.GetCurrentProxy()->FindResource(type, name);
	}
	
	DLL ResHandle addResource(int type, const char* name, int flags)
	{
		return g_proxyHandler.GetCurrentProxy()->AddResource(type, name, flags);
	}
	
	DLL ResHandle cloneResource(ResHandle sourceRes, const char* name)
	{
		return g_proxyHandler.GetCurrentProxy()->CloneResource(sourceRes, name);
	}
	
	DLL int removeResource(ResHandle res)
	{
		return g_proxyHandler.GetCurrentProxy()->RemoveResource(res);
	}
	
	DLL bool isResourceLoaded(ResHandle res)
	{
		return g_proxyHandler.GetCurrentProxy()->IsResourceLoaded(res);
	}
	
	DLL bool loadResource(ResHandle res, const char* data, int size)
	{
		return g_proxyHandler.GetCurrentProxy()->LoadResource(res, data, size);
	}
	
	DLL bool unloadResource(ResHandle res)
	{
		return g_proxyHandler.GetCurrentProxy()->UnloadResource(res);
	}
	
	DLL int getResourceParami(ResHandle res, int param)
	{
		return g_proxyHandler.GetCurrentProxy()->GetResourceParami(res, param);
	}
	
	DLL bool setResourceParami(ResHandle res, int param, int value)
	{
		return g_proxyHandler.GetCurrentProxy()->SetResourceParami(res, param, value);
	}
	
	DLL float getResourceParamf(ResHandle res, int param)
	{
		return g_proxyHandler.GetCurrentProxy()->GetResourceParamf(res, param);
	}
	
	DLL bool setResourceParamf(ResHandle res, int param, float value)
	{
		return g_proxyHandler.GetCurrentProxy()->SetResourceParamf(res, param, value);
	}
	
	DLL const char* getResourceParamstr(ResHandle res, int param)
	{
		return g_proxyHandler.GetCurrentProxy()->GetResourceParamstr(res, param);
	}
	
	DLL bool setResourceParamstr(ResHandle res, int param, const char* value)
	{
		return g_proxyHandler.GetCurrentProxy()->SetResourceParamstr(res, param, value);
	}
	
	DLL const void* getResourceData(ResHandle res, int param)
	{
		return g_proxyHandler.GetCurrentProxy()->GetResourceData(res, param);
	}
	
	DLL bool updateResourceData(ResHandle res, int param, const void* data, int size)
	{
		return g_proxyHandler.GetCurrentProxy()->UpdateResourceData(res, param, data, size);
	}
	
	DLL ResHandle queryUnloadedResource(int index)
	{
		return g_proxyHandler.GetCurrentProxy()->QueryUnloadedResource(index);
	}
	
	DLL void releaseUnusedResources()
	{
		g_proxyHandler.GetCurrentProxy()->ReleaseUnusedResources();
	}
	
	DLL ResHandle createTexture2D(const char* name, int flags, int width, int height, bool renderable)
	{
		return g_proxyHandler.GetCurrentProxy()->CreateTexture2D(name, flags, width, height, renderable);
	}
	
	DLL void setShaderPreambles(const char* vertPreamble, const char* fragPreamble)
	{
		g_proxyHandler.GetCurrentProxy()->SetShaderPreambles(vertPreamble, fragPreamble);
	}
	
	DLL bool setMaterialUniform(ResHandle materialRes, const char* name, float a, float b, float c, float d)
	{
		return g_proxyHandler.GetCurrentProxy()->SetMaterialUniform(materialRes, name, a, b, c, d);
	}
	
	DLL bool setPipelineStageActivation(ResHandle pipelineRes, const char* stageName, bool enabled)
	{
		return g_proxyHandler.GetCurrentProxy()->SetPipelineStageActivation(pipelineRes, stageName, enabled);
	}
	
	DLL bool getPipelineRenderTargetData(ResHandle pipelineRes, const char* targetName, int bufIndex, int* width, int* height, int* compCount, float* dataBuffer, int bufferSize)
	{
		return g_proxyHandler.GetCurrentProxy()->GetPipelineRenderTargetData(pipelineRes, targetName, bufIndex, width, height, compCount, dataBuffer, bufferSize);
	}
	
	DLL int getNodeType(NodeHandle node)
	{
		return g_proxyHandler.GetCurrentProxy()->GetNodeType(node);
	}
	
	DLL NodeHandle getNodeParent(NodeHandle node)
	{
		return g_proxyHandler.GetCurrentProxy()->GetNodeParent(node);
	}
	
	DLL bool setNodeParent(NodeHandle node, NodeHandle parent)
	{
		return g_proxyHandler.GetCurrentProxy()->SetNodeParent(node, parent);
	}
	
	DLL NodeHandle getNodeChild(NodeHandle node, int index)
	{
		return g_proxyHandler.GetCurrentProxy()->GetNodeChild(node, index);
	}
	
	DLL NodeHandle addNodes(NodeHandle parent, ResHandle sceneGraphRes)
	{
		return g_proxyHandler.GetCurrentProxy()->AddNodes(parent, sceneGraphRes);
	}
	
	DLL bool removeNode(NodeHandle node)
	{
		return g_proxyHandler.GetCurrentProxy()->RemoveNode(node);
	}
	
	DLL bool setNodeActivation(NodeHandle node, bool active)
	{
		return g_proxyHandler.GetCurrentProxy()->SetNodeActivation(node, active);
	}
	
	DLL bool checkNodeTransformFlag(NodeHandle node, bool reset)
	{
		return g_proxyHandler.GetCurrentProxy()->CheckNodeTransformFlag(node, reset);
	}
	
	DLL bool getNodeTransform(NodeHandle node, float* tx, float* ty, float* tz, float* rx, float* ry, float* rz, float* sx, float* sy, float* sz)
	{
		return g_proxyHandler.GetCurrentProxy()->GetNodeTransform(node, tx, ty, tz, rx, ry, rz, sx, sy, sz);
	}
	
	DLL bool setNodeTransform(NodeHandle node, float tx, float ty, float tz, float rx, float ry, float rz, float sx, float sy, float sz)
	{
		return g_proxyHandler.GetCurrentProxy()->SetNodeTransform(node, tx, ty, tz, rx, ry, rz, sx, sy, sz);
	}
	
	DLL bool getNodeTransformMatrices(NodeHandle node, const float* * relMat, const float* * absMat)
	{
		return g_proxyHandler.GetCurrentProxy()->GetNodeTransformMatrices(node, relMat, absMat);
	}
	
	DLL bool setNodeTransformMatrix(NodeHandle node, const float* mat4x4)
	{
		return g_proxyHandler.GetCurrentProxy()->SetNodeTransformMatrix(node, mat4x4);
	}
	
	DLL float getNodeParamf(NodeHandle node, int param)
	{
		return g_proxyHandler.GetCurrentProxy()->GetNodeParamf(node, param);
	}
	
	DLL bool setNodeParamf(NodeHandle node, int param, float value)
	{
		return g_proxyHandler.GetCurrentProxy()->SetNodeParamf(node, param, value);
	}
	
	DLL int getNodeParami(NodeHandle node, int param)
	{
		return g_proxyHandler.GetCurrentProxy()->GetNodeParami(node, param);
	}
	
	DLL bool setNodeParami(NodeHandle node, int param, int value)
	{
		return g_proxyHandler.GetCurrentProxy()->SetNodeParami(node, param, value);
	}
	
	DLL const char* getNodeParamstr(NodeHandle node, int param)
	{
		return g_proxyHandler.GetCurrentProxy()->GetNodeParamstr(node, param);
	}
	
	DLL bool setNodeParamstr(NodeHandle node, int param, const char* value)
	{
		return g_proxyHandler.GetCurrentProxy()->SetNodeParamstr(node, param, value);
	}
	
	DLL bool getNodeAABB(NodeHandle node, float* minX, float* minY, float* minZ, float* maxX, float* maxY, float* maxZ)
	{
		return g_proxyHandler.GetCurrentProxy()->GetNodeAABB(node, minX, minY, minZ, maxX, maxY, maxZ);
	}
	
	DLL int findNodes(NodeHandle startNode, const char* name, int type)
	{
		return g_proxyHandler.GetCurrentProxy()->FindNodes(startNode, name, type);
	}
	
	DLL NodeHandle getNodeFindResult(int index)
	{
		return g_proxyHandler.GetCurrentProxy()->GetNodeFindResult(index);
	}
	
	DLL int castRay(NodeHandle node, float ox, float oy, float oz, float dx, float dy, float dz, int numNearest)
	{
		return g_proxyHandler.GetCurrentProxy()->CastRay(node, ox, oy, oz, dx, dy, dz, numNearest);
	}
	
	DLL bool getCastRayResult(int index, NodeHandle* node, float* distance, float* intersection)
	{
		return g_proxyHandler.GetCurrentProxy()->GetCastRayResult(index, node, distance, intersection);
	}
	
	DLL int checkNodeVisibility(NodeHandle node, NodeHandle cameraNode, bool checkOcclusion, bool calcLod)
	{
		return g_proxyHandler.GetCurrentProxy()->CheckNodeVisibility(node, cameraNode, checkOcclusion, calcLod);
	}
	
	DLL NodeHandle addGroupNode(NodeHandle parent, const char* name)
	{
		return g_proxyHandler.GetCurrentProxy()->AddGroupNode(parent, name);
	}
	
	DLL NodeHandle addModelNode(NodeHandle parent, const char* name, ResHandle geometryRes)
	{
		return g_proxyHandler.GetCurrentProxy()->AddModelNode(parent, name, geometryRes);
	}
	
	DLL bool setupModelAnimStage(NodeHandle modelNode, int stage, ResHandle animationRes, const char* startNode, bool additive)
	{
		return g_proxyHandler.GetCurrentProxy()->SetupModelAnimStage(modelNode, stage, animationRes, startNode, additive);
	}
	
	DLL bool setModelAnimParams(NodeHandle modelNode, int stage, float time, float weight)
	{
		return g_proxyHandler.GetCurrentProxy()->SetModelAnimParams(modelNode, stage, time, weight);
	}
	
	DLL bool setModelMorpher(NodeHandle modelNode, const char* target, float weight)
	{
		return g_proxyHandler.GetCurrentProxy()->SetModelMorpher(modelNode, target, weight);
	}
	
	DLL NodeHandle addMeshNode(NodeHandle parent, const char* name, ResHandle materialRes, int batchStart, int batchCount, int vertRStart, int vertREnd)
	{
		return g_proxyHandler.GetCurrentProxy()->AddMeshNode(parent, name, materialRes, batchStart, batchCount, vertRStart, vertREnd);
	}
	
	DLL NodeHandle addJointNode(NodeHandle parent, const char* name, int jointIndex)
	{
		return g_proxyHandler.GetCurrentProxy()->AddJointNode(parent, name, jointIndex);
	}
	
	DLL NodeHandle addLightNode(NodeHandle parent, const char* name, ResHandle materialRes, const char* lightingContext, const char* shadowContext)
	{
		return g_proxyHandler.GetCurrentProxy()->AddLightNode(parent, name, materialRes, lightingContext, shadowContext);
	}
	
	DLL bool setLightContexts(NodeHandle lightNode, const char* lightingContext, const char* shadowContext)
	{
		return g_proxyHandler.GetCurrentProxy()->SetLightContexts(lightNode, lightingContext, shadowContext);
	}
	
	DLL NodeHandle addCameraNode(NodeHandle parent, const char* name, ResHandle pipelineRes)
	{
		return g_proxyHandler.GetCurrentProxy()->AddCameraNode(parent, name, pipelineRes);
	}
	
	DLL bool setupCameraView(NodeHandle cameraNode, float fov, float aspect, float nearDist, float farDist)
	{
		return g_proxyHandler.GetCurrentProxy()->SetupCameraView(cameraNode, fov, aspect, nearDist, farDist);
	}
	
	DLL bool getCameraProjectionMatrix(NodeHandle cameraNode, float* projMat)
	{
		return g_proxyHandler.GetCurrentProxy()->GetCameraProjectionMatrix(cameraNode, projMat);
	}
	
	DLL NodeHandle addEmitterNode(NodeHandle parent, const char* name, ResHandle materialRes, ResHandle particleEffectRes, int maxParticleCount, int respawnCount)
	{
		return g_proxyHandler.GetCurrentProxy()->AddEmitterNode(parent, name, materialRes, particleEffectRes, maxParticleCount, respawnCount);
	}
	
	DLL bool advanceEmitterTime(NodeHandle emitterNode, float timeDelta)
	{
		return g_proxyHandler.GetCurrentProxy()->AdvanceEmitterTime(emitterNode, timeDelta);
	}
	
	DLL bool hasEmitterFinished(NodeHandle emitterNode)
	{
		return g_proxyHandler.GetCurrentProxy()->HasEmitterFinished(emitterNode);
	}
	

}