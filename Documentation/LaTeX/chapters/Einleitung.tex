\chapter{Einleitung}\label{Einleitung}

Die Entwicklungskosten für Videospiele nehmen seit vielen Jahren kontinuierlich zu. Heute kostet ein modernes Spiel für Sonys PlayStation 3 im Durchschnitt 15 Millionen Dollar \cite{gameheadache}. Aber auch das technisch weniger aufwendige Braid\footnote{\url{http://braid-game.com}} für Microsofts Xbox Live Arcade, das mit Ausnahme des Artworks und des Soundtracks allein von Jonathan Blow entwickelt wurde, kostete in seiner Entwicklung bereits 200.000 Dollar \cite{braidwiki}.

Aufgrund des Kostendrucks wird bei der Entwicklung eines Spiels oftmals auf bereits vorhandene Subsysteme zurückgegriffen, wie beispielsweise die 3D Grafik-Engines Source\footnote{\url{http://source.valvesoftware.com}}, id tech 4\footnote{\url{http://www.idsoftware.com/business/idtech4}}, Unreal Engine 3\footnote{\url{http://www.unrealtechnology.com}} und Gamebryo\footnote{\url{http://www.emergent.net}}; die Physik-Engines Havok\footnote{\url{http://www.havok.com}} und PhysX\footnote{\url{http://www.nvidia.com/object/nvidia_physx.html}}; oder auch SpeedTree\footnote{\url{http://www.speedtree.com}}, eine Library zur Erstellung animierter 3D-Bäume. Da die Erstellung von Spielen auch für Hobby- und Open Source-Entwickler immer aufwendiger wird, unterstützen auch im Open Source-Bereich eine Vielzahl an Bibliotheken die Entwicklung; unter anderem die 3D Grafik-Engines Irrlicht\footnote{\url{http://irrlicht.sourceforge.net}}, OGRE\footnote{\url{http://www.ogre3d.org}} und Horde3D\footnote{\url{http://www.horde3d.org}}.

Nicolas Schulz veröffentlichte am 25. September 2006 die erste Version von \Horde. Unterstützt wird die Entwicklung durch den Lehrstuhl für Multimedia-Konzepte und Anwendungen der Universität Augsburg. Der Lehrstuhl verwendete die Engine bereits als Grundlage für einige Forschungsprojekte wie etwa das Facial Animation System Alfred\footnote{\url{http://mm-werkstatt.informatik.uni-augsburg.de/alfred-virtual-character.html}}, oder auch für das Spiel SheepMeUp\footnote{\url{http://mm-werkstatt.informatik.uni-augsburg.de/SheepMeUp.html}}, das im Rahmen des Multimedia Praktikums im Sommersemester 2008 von Studenten der Universität Augsburg entwickelt wurde.

%Es gibt viele verschiedene 3D Grafik-Engines, sowohl kommerziell als auch Open Source, die alle von der zugrunde liegenden Grafik-API abstrahieren und als Framework für Licht- und Schattenberechnung, Post Processing-Effekte, Partikelsysteme und vieles mehr eingesetzt werden. Beispiele für bekannte Open Source Engines sind \textit{Irrlicht}\footnote{http://irrlicht.sourceforge.net/}, \textit{OGRE}\footnote{http://www.ogre3d.org/} und die ehemals kommerzielle \textit{Quake 3 Engine}\footnote{http://www.idsoftware.com/business/techdownloads/} von \textit{id Software}. Die Entwickler wollen \Horde\ jedoch von den anderen Engines durch ein besonderes Design-Ziel abgrenzen:

\Horde\ grenzt sich gegenüber den anderen kommerziellen und frei verfügbaren Engines durch ein besonderes Design-Ziel ab:

\begin{quote}
"`One of the most important design goals of Horde3D is to keep things simple and avoid complexity where possible without sacrificing flexibility or productivity. [...] Much of the power and flexibility of the engine comes from its shader driven architecture and customizable pipeline that makes it possible to apply nearly all modern rendering and post processing techniques."' \cite{h3dmanual}
\end{quote}

Den Anwendungsprogrammierern bietet \Horde\ eine API, die einfach zu verwenden ist und dennoch größtmögliche Flexibilität gewährleistet. Jedoch beinhaltet die Engine keine Tools, um zum Beispiel die angesprochenen \emph{Post Processing} Techniken zu entwickeln und mit dem \emph{Look and Feel} der Anwendung abzustimmen. Nur für das Zusammenstellen von Szenen gibt es Volker Wiendls Horde3D Scene Editor\footnote{\url{http://mm-werkstatt.informatik.uni-augsburg.de/project_details.php?id=45}}.

Bei der Entwicklung von SheepMeUp sind Mängel in der Toolunterstützung von \Horde\ deutlich geworden: Das Spiel verwendet einige Shader- und Partikel-basierte Special Effects zur Darstellung von Kraftfeldern, Schockwellen und Zaubersprüchen. Dank der flexiblen Rendering-Pipeline der Engine konnten diese Effekte leicht eingebunden werden. Schwierigkeiten ergaben sich erst bei der Feinabstimmung, da die Rendering-Pipeline, Materials, Shader- und Partikeleffekte nur durch Bearbeiten der zugrundeliegenden XML-Dateien geändert werden konnten. Die Wichtigkeit der Effekte als Teil der Ästhetik des Spiels sollte aber nicht unterschätzt werden; die Ästhetik ist ein Grundstein des \emph{Elemental Tetrad} \cite[S. 41ff]{schell} und somit eines der vier Basis-Elemente eines Spiels. Die Ästhetik beeinflusst die drei anderen Basis-Elemente -- Spielemechanik, Story und verwendete Technologie -- und kann ausschlaggebend sein, ob ein Spiel als gut empfunden wird oder nicht. Umgekehrt sollte die verwendete Technologie das Finetuning der Effekte unterstützen und vereinfachen, um die Ästhetik des Spiels möglichst einfach und schnell -- und damit kostengünstig -- perfektionieren zu können.

Aufbauend auf den gewonnen Erfahrungen bei der Entwicklung von SheepMeUp wird im Rahmen dieser Bachelorarbeit ein Shader und Special Effects Management Tool, das \DevEnv, entworfen und implementiert. Das Tool soll es erleichtern, die Pipeline-Konfiguration, Materials, sowie Shader- und Partikeleffekte zu optimieren, anzupassen und abzustimmen. Außerdem soll das Tool mit jeder \Horde-Anwendung zusammenarbeiten.
% -- an der Anwendung soll dafür nichts geändert werden müssen.
%\footnote{Eine kleine Änderung an der Anwendung ist doch nötig. Dies ist allerdings lediglich ein "`Sicherheitsaspekt"' um unerwünschtes Reverse-Engineering zu verhindern.}
Es soll jedoch nicht möglich sein, Anwendungs- oder Shader Code zu debuggen. Dafür gibt es bereits eine Reihe ausgereifter Standardentwicklungswerkzeuge.

Diese Arbeit beschreibt den Entwurf und die Implementierung der Anwendung in den drei Phasen der Softwareentwicklung: zunächst die Anforderungsanalyse, dann das Design und die Struktur des Systems und schließlich die Implementierung in \C++ und \Csharp. Es werden die jeweils getroffenen Entscheidungen und ausgewählte Teile der erstellten Artefakte jeder Phase erläutert. Die einzelnen Entwicklungsphasen wurden jedoch, angelehnt an den \emph{Unified Process}, in mehreren Iterationen durchlaufen.
% durchlaufen und bei der Implementierung wurde inkrementell vorgegangen; es wurde immer zuerst ein Teil des System fertiggestellt und danach mit der Entwicklung des nächsten Teils begonnen. Dennoch wurde für diese Arbeit eine chronologische Beschreibung gewählt, um eine klarere und kompaktere Darstellung zu ermöglichen. 
Sollte eine wichtige Entscheidung erst in einer späteren Iteration getroffen worden sein, so wird dies an der entsprechenden Stelle erwähnt.

Abschließend wurde das Tool für die Entwicklung eines neuen Effekts für ein Raumschiff-Spiel eingesetzt und von einigen Entwicklern von \Horde\ und \SheepMeUp\ getestet und bewertet. Davon ausgehend werden Erweiterungen und Verbesserungsmöglichkeiten für das \DevEnv\ vorgeschlagen.