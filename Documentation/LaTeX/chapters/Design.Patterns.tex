\section{Angewandte Entwurfsmuster}
In der Softwareentwicklung gibt es für ein spezielles Architektur-Problem oftmals mehrere mög\-liche Lösungswege. Diese sind je nach Situation besser oder schlechter geeignet. Eine der wichtigsten Fähigkeiten eines Softwarearchitekten ist es daher, unterscheiden zu können, was für ein gegebenes Problem derjenige Lösungsansatz ist, der zum bestmöglichen Design führt \cite[S. 4]{cpp}. Auf der anderen Seite gibt es in der Softwareentwicklung eine Vielzahl an wiederkehrenden Entwurfsproblemen, für die es bewährte Lösungsschablonen gibt. Die Schablonen, \emph{Design Patterns} oder Entwurfsmuster genannt, stellen eine allgemeine Vorlage zur Problemlösung dar, die nur noch auf den spezifischen Kontext des Problems angepasst werden muss. Gut strukturierte, objekt-orientierte Softwarearchitekturen verwenden eine Vielzahl an unterschiedlichen \emph{Design Patterns} \cite{gangOfFour}.

Beim Design des \DevEnvs\ wurden verschiedene \emph{Design Patterns} angewandt, die im folgenden kurz vorgestellt werden. Bei der Vorstellung des Systemdesigns wird immer wieder auf die Verwendung der \emph{Patterns} zur Lösung eines Design-Problems hingewiesen.

\subsection{General Responsibility Assignment Software Patterns}
Für die Zuweisung der Verantwortlichkeiten auf die einzelnen Klassen wurden einige der \emph{General Responsibility Assignment Software Patterns} verwendet \cite{grasp}. Da die \emph{Patterns} aber die Grundlage für objekt-orientierte Entwürfe bilden und somit vielfach angewandt wurden, wird auf eine Instanziierung eines GRAS Entwurfsmuster im Designmodell nicht hingewiesen. Im folgenden seien die verwendeten \emph{GRAS Patterns} aber kurz vorgestellt:

\begin{itemize}
	\item \textbf{Expert:} \emph{Expert} ist das allgemeinste \emph{Pattern}. Diejenige Klasse sollte die Verantwortlichkeit erhalten, die alle benötigten Informationen dafür besitzt.
	\item \textbf{Creator:} Das \emph{Creator Pattern} gibt Hinweise darauf, welche Klasse eine Instanz einer anderen Klasse erzeugen sollte. Ein Objekt $B$ sollte ein Objekt $A$ erzeugen, wenn beispielsweise $B$ eine Aggregation von $A$ ist, oder $B$ die benötigten Initialisierungsdaten für $A$ besitzt.
	\item \textbf{Low Coupling:} Mit Kopplung bezeichnet man das Maß der Abhängigkeit einer Klasse von anderen Klassen. Eine niedrige Kopplung ist eines der wichtigsten Ziele von gutem objekt-orientierten Design, da es die Wiederverwendbarkeit erhöht und auch die Verständlichkeit und Wartbarkeit des Codes verbessert.
	\item \textbf{High Cohesion:} Die Kohäsion einer Klasse bezeichnet den semantischen Zusammenhang der Verantwortlichkeiten einer Klasse. Eine Klasse sollte möglichst wenige verschiedene Aufgaben enthalten, um eine hohe Kohäsion zu erreichen. Dadurch werden die Klassen kleiner, die Verantwortlichkeiten einer Klasse genauer definiert und der Code damit insgesamt besser wartbar, verständlich und wiederverwendbar. Jedoch steht das \emph{High Cohesion Pattern} im Widerspruch zu \emph{Low Coupling}. Beim Softwareentwurf muss daher eine angemessene Balance gefunden werden.
	\item \textbf{Polymorphismus:} Polymorphismus ist ein grundlegendes \emph{Pattern} der objekt-orientier\-ten Entwicklung, das von allen modernen objekt-orientierten Programmiersprachen direkt unterstützt wird. Durch die Verwendung von virtuellen und polymorphen Funktionen kann das Verhalten abhängig vom konkreten Typ der Klasse(n) geändert werden.
	\item \textbf{Pure Fabrication:} Mit \emph{Pure Fabrication} bezeichnet man die Einführung von Design-Klassen, die im Design eine spezielle Aufgabe übernehmen, im Konzeptmodell aber nicht vorhanden sind.
\end{itemize}

\subsection{Gang of Four Design Patterns}
Der Entwurf des \DevEnvs\ verwendet einige der bekannten und oft eingesetzten \emph{Design Patterns} der \emph{Gang Of Four} \cite{gangOfFour}. Diejenigen dieser Entwurfsmuster, die für das Systemdesign eingesetzt wurden, seinen hier kurz erläutert; an den entsprechenden Stellen wird auf ihre genaue Verwendung hingewiesen.

\begin{itemize}
	\item \textbf{Composite:} Das \emph{Composite Pattern} \cite[S. 163ff]{gangOfFour} fügt mehrere Objekte in einer Baumstruktur zusammen, um eine Teil-Ganzes-Hierarchie zu repräsentieren. Ein Knoten muss nicht unterscheiden, ob eines seiner Kinder ein Blatt oder wiederum ein Knoten mit weiteren Kindern ist. Primitive Objekte und Behälter können also uniform behandelt werden.
	\item \textbf{Facade:} Das \emph{Facade Pattern} \cite[S. 185ff]{gangOfFour} fasst verschiedene Interfaces unter einem gemeinsamen, einfacher benutzbaren Interface zusammen. Damit werden Komplexität und Abhängigkeiten reduziert, und somit das System besser wartbar.
	\item \textbf{Command:} Beim \emph{Command Pattern} \cite[S. 233ff]{gangOfFour} wird eine Operation durch ein Objekt gekapselt. Durchgeführte Operationen können parametrisiert und protokolliert werden. Dadurch wird es möglich, Operationen später rückgängig zu machen.
	\item \textbf{Observer:} Das \emph{Observer Pattern} \cite[S. 293ff]{gangOfFour} wird direkt von zwei \Csharp-Sprachfeatures unterstützt: \emph{Delegates} und \emph{Events}. Objekte können einen speziellen \emph{Event Handler Delegate} für ein \emph{Event} eines (anderen) Objekts registrieren. Löst das Objekt das Ereignis aus, werden alle registrierten \emph{Delegates} automatisch ausgeführt. Das Objekt muss dafür nicht wissen, welche Objekte oder ob überhaupt Objekte an diesem Ereignis interessiert sind. Mit Hilfe dieses \emph{Patterns} kann eine \emph{One-To-Many}-Beziehung definiert werden, ohne zusätzliche Abhängigkeiten einzuführen.
	\item \textbf{Singleton:} Das \emph{Singleton Design Pattern} \cite[S. 127ff]{gangOfFour} stellt sicher, dass es nur eine Instanz einer Klasse geben kann. Für diese Instanz gibt es einen einzigen, globalen Zugriffspunkt.
	\item \textbf{Strategy:} Eine Menge von Algorithmen zur Lösung eines Problems kann mit dem \emph{Strategy Pattern} \cite[S. 315]{gangOfFour} gekapselt werden. Zur Laufzeit kann dann der am besten passende Algorithmus zur Lösung des Problems ausgewählt werden.
	\item \textbf{Decorator:} Das \emph{Decorator Pattern} \cite[S. 175]{gangOfFour} ermöglicht es, Verantwortlichkeiten dynamisch zur Laufzeit zu einem Objekt hinzuzufügen und wieder zu entfernen. Mit der klassische Vererbung hingegen können Verantwortlichkeiten nur statisch hinzugefügt werden.
	\item \textbf{Template Method:} Beim \emph{Template Method Pattern} wird in einer Methode ein Algorithmus definiert, wobei manche Schritte als abstrakte oder virtuelle Methoden gekapselt sind. Abgeleitete Klassen müssen oder können diese Methoden überschreiben und so einzelne Schritte, nicht aber die Struktur des Algorithmus, verändern. Die Unterstützung von Lambda-Funktionen in \Csharp\ ermöglicht eine Variation des \emph{Patterns}: Dem Algorithmus werden Lambda-Funktionen übergeben, die der Algorithmus an ausgewiesenen Stellen ausführt. Die Lambda-Funktionen ersetzen somit die abstrakten oder virtuellen Methoden.
\end{itemize}

\subsection{Model-View-Presenter Design Pattern}
Die Anbindung der GUI an das System ist über das \emph{Model-View-Presenter Design Pattern} umgesetzt. Leider gibt es für dieses Entwurfsmuster keine genaue Definition; es gibt mehrere verschiedene Varianten und die Abgrenzung zum \emph{Model-View-Controller Pattern} ist ebenfalls nicht ganz klar \cite[Abschnitt "`Model-View-Controller and Model-View-Presenter Confusion"']{mvpconfusion}. Der gemeinsame Nenner ist lediglich die Separation der Anwendung in drei Bereiche: 

\begin{itemize}
	\item \textbf{Models:} Die Modelle sind die eigentlichen Businessobjekte der Anwendung aus dem Designmodell. Sie können gegebenenfalls mit dem \emph{Facade} oder \emph{Controller Pattern} gekapselt sein, um das Zugriffsinterface für die GUI-Anbindung zu vereinfachen.
	\item \textbf{Views:} Die \emph{Views} sind für die grafische Anzeige zuständig. Sie sind die einzigen Klassen, die Abhängigkeiten zum gewählten GUI-Framework wie Windows Forms oder der Windows Presentation Foundation haben. Die \emph{Views} zeigen die Daten der Modelle an; wie sie allerdings an die Daten kommen, ist nicht genau definiert.
	\item \textbf{Presenters:} Die Rolle der \emph{Presenter} ist ebenfalls nicht klar festgelegt. Fest steht, dass die \emph{Views} auf Benutzereingaben nicht selbst reagieren, sondern diese an ihren jeweiligen \emph{Presenter} weiterreichen. Ob ein \emph{Presenter} Daten an seine \emph{View} schicken darf, hängt von der verwendeten Variante des \emph{Model-View-Presenter Patterns} ab.
\end{itemize}

\begin{figure}[ht]
\centering
%trim=l b r t  	This option will crop the imported image by l from the left, b from the bottom, r from the right, and t  from the top. Where l, b, r and t are lengths. 
\includegraphics[trim = 2mm 238mm 80mm 2mm, clip, scale=0.7]{images/MVP.pdf}
\caption{Überblick über die \emph{Supervising Controllers} Variante des \emph{MVP Patterns}}\label{fig:mvp}
\end{figure}

Abbildung~\ref{fig:mvp} zeigt die \emph{Supervising Controllers} Variante des \emph{MVP Patterns} \cite{fowler}, welche vom \DevEnv\ verwendet wird. Jeder \emph{Presenter} hat genau eine \emph{View} und umgekehrt. Der \emph{Presenter} kennt seine \emph{View} und kann diese jederzeit aktualisieren und auf deren Daten zugreifen. Die \emph{View} hingegen kennt ihren \emph{Presenter} nicht. Um die Benutzereingaben dennoch an den \emph{Presenter} weiterleiten zu können, werden \emph{Events} verwendet. Der \emph{Presenter} reagiert darauf und aktualisiert gegebenenfalls die Daten des Modells. 

Die \emph{View} erhält ihre Daten entweder vollständig vom \emph{Presenter}, oder kann diese aus dem Modell auslesen. Ändert sich das Modell, so werden die Änderungen über \emph{Events} sowohl an den \emph{Presenter} als auch an die \emph{View} geschickt. Im Regelfall bindet sich die \emph{View} per \emph{Databinding} an das Modell und wird so -- ohne zusätzlichen Code -- automatisch aktualisiert, wenn sich das Modell ändert. Der \emph{Presenter} kann ebenfalls auf Änderungen des Modells reagieren, um komplexere Präsentationslogik auszuführen und dann die \emph{View} zu aktualisieren. 
