\section{Grundlegende Entscheidungen}\label{decisions}	
Eine Anforderung an das System war die Unabhängigkeit von \Horde\ und der Anwendung des Benutzers. Bereits in der Design-Phase musste daher sichergestellt werden, dass die Implementierung keine Änderungen an \Horde\ oder der Benutzeranwendung voraussetzt. Die \emph{Use Cases} fordern zusätzlich, dass das System die Anwendung des Benutzers starten und beenden kann. Eine Client-Server-Architektur zwischen \DevEnv\ und Anwendung, welche  service-orientiert entworfen wurde, erfüllt diese Anforderungen. Was nun als Server bezeichnet wird, ist in diesem Fall allerdings nicht klar. Für die \Horde-Anwendung spricht, dass sie die Daten hält, die von dem System ausgelesen und angezeigt werden. Für das System spricht hingegen, dass es die ganze Zeit läuft und die \Horde-Anwendung erst starten muss. Das Festlegen einer genauen Terminologie wird zusätzlich durch den Einsatz eines DLL-\emph{Replacement}-Mechanismus erschwert. Die originale \Horde\ DLL wird durch eine modifizierte Version ersetzt, die alle \Horde-Funktionsaufrufe -- für die Anwendung völlig transparent -- an die Original-DLL weiterleitet und intern noch zusätzlichen Code ausführt. Dadurch schleust das \DevEnv\ Code in die \Horde-Anwendung ein; das System läuft sowohl server- als auch client-seitig. 

In den nächsten Abschnitten wird nun folgende Terminologie verwendet: Mit "`\Horde-Anwendung"' ist die Anwendung des Benutzers gemeint, ohne DLL-\emph{Replacement}. "`Server"' bezeichnet den Code des \DevEnvs, der innerhalb des Prozesses der \Horde-Anwendung läuft. "`Client"' oder "`Shell"' ist der Teil des Systems, der als eigenständige Applikation lauffähig ist und Server-Instanzen starten und beenden kann. 

\begin{figure}[ht]
\centering
%trim=l b r t  	This option will crop the imported image by l from the left, b from the bottom, r from the right, and t  from the top. Where l, b, r and t are lengths. 
\includegraphics[trim = 3mm 100mm 15mm 12mm, clip, scale=0.7]{images/Prozess.pdf}
\caption{Interaktionen zwischen Client und Server an einem Beispiel}\label{fig:prozess}
\end{figure}

Abbildung~\ref{fig:prozess} verdeutlicht die Interaktionen zwischen Server und Client an einem Beispiel. Der Client wird dabei durch die Lebenslinie des linken Akteurs repräsentiert, die rechte Lebenslinie repräsentiert den Server. Die Shell führt zunächst ein paar vorbereitende Schritte durch -- unter anderem das DLL-\emph{Replacement} sowie einige Konfigurationsaufgaben -- und startet schließlich die \Horde-Anwendung. Anstelle der Original-DLL wird jedoch die modifizierte \Horde\ DLL geladen und initialisiert. Während der Initialisierung wird schließlich die originale \Horde\ DLL in den Prozess geladen. Anschließend wird die Anwendung normal ausgeführt und alle von \Horde\ generierten Meldungen sofort an den Client geschickt.

Zu einem beliebigen Zeitpunkt weist der Benutzer die Shell an, die \Horde-Anwendung zu pausieren. Nun können alle relevanten Daten -- beispielsweise der aktuelle Zustand des Szenengraphs oder die derzeit bekannten Ressourcen -- aus dem Server ausgelesen werden. Anschließend wird eine Ressource verändert und deren aktualisierte Daten wieder an den Server geschickt, der die entsprechende \Horde-Ressource aktualisiert. Danach wird die Anwendung fortgesetzt und beim Zeichnen die aktualisierte Ressource verwendet, bis die Shell den Server schließlich beendet.

\begin{figure}[ht]
\centering
%trim=l b r t  	This option will crop the imported image by l from the left, b from the bottom, r from the right, and t  from the top. Where l, b, r and t are lengths. 
\includegraphics[scale=0.38]{images/VS.png}
\caption{Die grafische Benutzeroberfläche von Visual Studio 2008}\label{fig:vs}
\end{figure}

Auch über die grafische Benutzeroberfläche wurde bereits am Anfang der Design-Phase nachgedacht. Das \emph{User Interface} sollte sich an GUIs bekannter Entwicklungsumgebungen wie Visual Studio und Eclipse orientieren. Abbildung~\ref{fig:vs} verdeutlicht die geplante GUI am Beispiel von Visual Studio 2008: In der Mitte des \emph{Workspaces} werden mehrere Dokumente oder grafische Designer angezeigt. Oben gibt es die bereits von Windows bekannten Menüs und \emph{Toolbars}. An der rechten und an der unteren Seite sind verschiedene \emph{Tool Windows} versteckt, die erst beim Berühren mit der Maus sichtbar werden. Links ist das \emph{Solution Explorer Tool Window} "`angedockt"'. Die \emph{Tool Windows}, auch \emph{Dock Panes} genannt, können vom Benutzer frei positioniert sowie versteckt und wieder sichtbar gemacht werden. Es besteht auch die Möglichkeit, die \emph{Dock Panes} als eigenes Fenster (\emph{Floating Window}) über die Anwendung zu legen. Das vom Benutzer frei gewählte Layout wird gespeichert und beim Starten der Anwendung automatisch wiederhergestellt. 

Das \DevEnv\ wurde im Hinblick auf ein solches GUI-Design entworfen, da es weit verbreitet und bekannt ist und es dem Benutzer viele Möglichkeiten lässt, die Oberfläche an seine Wünsche und Vorlieben anzupassen. 

Zu Beginn der Design-Phase wurde auch entschieden, dass das System in \Csharp\ mit dem .NET Framework 3.5 Service Pack 1 implementiert wird. Dadurch ist das System zwar nur unter Windows lauffähig, aufgrund der höheren Produktivität gegenüber einer Implementierung mit \C++ und Qt konnte bei der Entwicklung jedoch mehr Zeit in die eigentlich zu lösenden Probleme investiert werden. Diese Entscheidung wurde bereits zu diesem Zeitpunkt getroffen, damit schon in den Design-Artefakten .NET \emph{Properties} und \emph{Events} verwendet werden können, was die Darstellung erleichtert und verkürzt. Da UML jedoch keine Unterstützung für diese Konzepte anbietet, wurden die entsprechenden UML-Attribute und -Operationen mit den Stereotypen \texttt{property} (\emph{Getter} und \emph{Setter} für Attribute), \texttt{event} (ein Ereignis, das auftreten kann) und \texttt{event property} (an diesem kann sich ein Objekt für ein \emph{Event} registrieren und deregistrieren) versehen.

All diese Entscheidungen hatten einen großen Einfluss auf den Gesamtentwurf des Systems. Deshalb war es wichtig zu überprüfen, ob die vorgestellten Konzepte überhaupt wie geplant umsetzbar sind. Vor dem Entwurf der Design-Dokumente wurde daher ein Prototyp entwickelt, der die Machbarkeit der Konzepte überprüfte und als durchführbar bestätigte.