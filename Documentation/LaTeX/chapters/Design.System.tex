\section{System-Architektur}
In der ersten Iteration der Design-Phase wurde bereits die gesamte Architektur des \DevEnvs\ entworfen. Der erste Entwurf erwies sich als recht stabil und erforderte in späteren Iterationen nur wenige Modifikationen. Die erstellten Artefakte, ein Designmodell und mehrere Sequenzdiagramme, werden in den folgenden Abschnitten besprochen und die getroffenen Entscheidungen begründet. Das Designklassen-Diagramm ist allerdings zu groß, um es im Anhang dieser Arbeit abzubilden. Daher werden nur relevante Ausschnitte des Modells im Anhang beigelegt; das komplette Modell ist als .pdf-Datei auf der CD-ROM enthalten.

Da UML keine Syntax für .NET \emph{Properties} anbietet, wurde der Stereotyp \texttt{property} eingeführt. In der Implementierung wurden dann \texttt{Get/SetX}-Methoden mit \texttt{property}-Stereotyp als entsprechende \emph{Properties} \texttt{X \{ get; set; \}} umgesetzt. Aus Gründen der Übersichtlichkeit wurden im Designmodell für viele öffentliche Attribute keine \emph{Properties} definiert; sie werden später aber als öffentliche \emph{Properties} implementiert, da laut den .NET Richtlinien der Zugriff auf öffentliche Klassenattribute immer durch \emph{Properties} gekapselt sein sollte \cite{fields}.

\subsection{\Horde-Klassen}
Die aus dem Konzeptmodell bekannten \Horde-Klassen wurden in das Designmodell über-nommen; alle Klassenattribute, die Assoziationen zwischen den Klassen und die Vererbungshierarchien sind unverändert. Es wurden allerdings mehrere Funktionen ergänzt. So erhält die abstrakte Klasse \texttt{SceneNode} die virtuelle Methode \texttt{InitializeFromHorde3DState}, die aus dem aktuellen \Horde-Zustand beispielsweise die Transformationswerte und den Vaterknoten ausliest. Alle abgeleiteten Klassen können diese Methode überschreiben, um ihre eigenen Daten auszulesen. Dabei können sie auf die \texttt{SceneNode}-Implementierung zurückgreifen, um die von \texttt{SceneNode} geerbten Attribute und Assoziationen zu füllen beziehungsweise aufzubauen.

Ein analoges Vorgehen wurde für die Ressourcen-Hierarchie angewandt. Die abstrakte Klasse \texttt{Resource} besitzt ebenfalls eine virtuelle Methode \texttt{InitializeFromHorde3DState}, die in ihrer Standardimplementierung die \texttt{Resource}-Attribute und -Assoziationen ausliest und von den Subklassen überschrieben werden sollte. Die Klasse \texttt{EditableResource} führt zwei weitere abstrakte Methoden ein: \texttt{SaveToDisk} und \texttt{LoadFromDisk}. Konkrete Subklassen müssen diese Funktionen so implementieren, dass ihre Attribute und Assoziationen in das \Horde-XML-Format übersetzt werden, beziehungsweise aus diesem ausgelesen und aufgebaut werden. Jedoch können manche Assoziationen nur dynamisch aus dem aktuellen \Horde-Zustand ermittelt werden, da sie in den XML-Dateien nicht gespeichert sind.

\subsection{Client-Server-Schnittstelle}
Wie bereits in Abschnitt~\ref{decisions} ausgeführt, zerfällt das System in einen Client- und einen Serverteil. Da in der Design-Phase bereits die Windows Communication Foundation (WCF) als Netzwerk-Framework ausgewählt wurde, orientiert sich das Design der Client-Server-Schnittstelle an der Terminologie und an den Fähigkeiten von WCF. 

Abbildung~\ref{fig:clientServerInterfaceDesign} zeigt einen Ausschnitt aus dem Designmodell für die Client-Server-Schnitt-stelle. Zunächst wurde das Interface \texttt{IDebuggerService} spezifiziert, über das der Client auf den Server zugreifen kann. Der Service hat je eine Funktion für jede Systemanforderung: \texttt{Suspend} und \texttt{Resume}, um die Anwendung anzuhalten und wieder fortzusetzen; \texttt{Profile}, um die Profiling-Daten zu generieren; \texttt{GetRenderTargetData}, um den Inhalt eines \emph{Render Targets} auszulesen; und \texttt{UpdateResource}, um aktualisierte Ressource-Daten zu übermitteln und an \Horde\ weiterzureichen.

Ursprünglich lieferten die Funktionen bereits die jeweilig benötigten Daten zurück. %, was jedoch zu Deadlocks und Inkonsistenzen bei der Implementierung führte\footnote{Die Deadlocks konnten entstehen, wenn während einer WCF-Operation weitere Benutzereingaben bearbeitet wurden. Da die WCF-Aufrufe sowohl client- als auch serverseitig immer in einem speziellen Thread stattfinden müssen.}. 
In der zweiten Iteration wurde hingegen das \texttt{IDebuggerServiceCallback}-Interface eingeführt. Der Server verwendet dieses Interface, um dem Client Daten und Ereignisse zu übermitteln. Das \emph{Callback}-Interface vereinfachte das Einfrieren, Fortsetzen und Profilen der Anwendung aus der Anwendung selbst heraus. Wenn der Benutzer eine bestimmte Taste innerhalb der Anwendung drückt, schickt der Server per \emph{Callback} eine Meldung an den Client, und dieser kann darauf entsprechend reagieren. Ohne \emph{Callbacks} wäre das in Sequenzdiagramm~\ref{fig:ClientServerCommunication} gezeigte Vorgehen nicht umsetzbar gewesen. Dort werden die \emph{Service}- und \emph{Callback}-Interaktionen beim Anhalten der Anwendung gezeigt. Der Client erhält vom Benutzer den Befehl zum Anhalten der Anwendung und ruft den \emph{Service} auf, welcher wiederum den Server informiert. Alternativ erteilt der Benutzer den Befehl durch einen Tastendruck innerhalb Anwendung direkt an den Server. In beiden Fällen ruft der Server die \texttt{OnSuspended}-Methode des \emph{Callbacks} auf. Eine Implementierung des \emph{Callback}-Interfaces würde den Client beispielsweise durch Auslösen eines \emph{Events} darüber informieren, dass die Anwendung angehalten wurde; der Client geht bis zu diesem Zeitpunkt in beiden Fällen immer noch davon aus, dass die Anwendung noch läuft. Kam der \texttt{Suspend}-Aufruf direkt vom Server, so kann der Client davon nichts wissen. Kam der Aufruf hingegen vom Client selbst, so wurde er nur an den Server weitergereicht, aber sonst nicht darauf reagiert. Dadurch kann der Client unabhängig vom Ursprung des \texttt{Suspend}-Befehls die gleichen Aktionen durchführen. 

Erst wenn der Client durch den \emph{Callback} über das Einfrieren der Anwendung informiert wurde, fordert er mit der \texttt{RequestDebugData}-Methode des \emph{Services} die aktuellen Szenen\-graph- und Ressourcendaten an. Der Server schickt dann jede \emph{Scene Node} und jede Ressource einzeln über das \emph{Callback} Interface an den Client, der mit den Objekten entsprechend weiterarbeitet. Beim Fortsetzen oder Profilen der Anwendung wäre das Verfahren analog, es würden nur andere beziehungsweise gar keine Daten per \emph{Callback} an den Client zurückgeschickt werden. Eine Ausnahme bildet hingegen das Auslesen des Inhalts eines \emph{Render Targets}. Da die Anfrage ausschließlich vom Client kommen kann, bringt das \emph{Callback}-Verfahren hier keine Vorteile. Aus diesem Grund liefert die Funktion \texttt{GetRenderTargetData} das Ergebnis direkt zurück.

Ein weiterer Vorteil des \emph{Callback}-Interfaces ist die Möglichkeit, generierte \Horde-Mel\-dungen unverzüglich an den Client schicken zu können. Dies erspart ein kontinuierliches Nachfragen des Clients beim Server, ob neue Nachrichten erstellt wurden. Zusätzlich werden alle \emph{Scene Nodes}, Ressourcen, \Horde-Meldungen und Profiling-Objekte einzeln übertragen, was bei großen Datenmengen die Reaktionszeit des Clients verbessert. Statt auf die Übertragung des gesamten Datensatzes warten zu müssen, kann der Client nach und nach jedes Objekt, das er bereits erhalten hat, einzeln darstellen. 

Problematisch an der Einführung des \emph{Callback}-Interfaces war hingegen, dass es prinzipiell möglich sein könnte, dass \emph{Callbacks} vor dem Verbindungsaufbau aufgerufen werden. Aus diesem Grund stellt die Implementierung einen Sicherungsmechanismus bereit, der \emph{Callback}-Aufrufe abfängt und erst dann an den Client übermittelt, wenn die Verbindung aufgebaut wurde.

Auf der Clientseite kennt nur die Klasse \texttt{Horde3DApplication} eine Instanz der Klasse \texttt{DebuggerServiceProxy}, über die der Client mit dem Server kommunizieren kann. Dabei repräsentiert \texttt{Horde3DApplication} wie bereits im Konzeptmodell eine konkrete \Horde-Anwendung. Um eine Anwendung starten zu können, werden gewisse Informationen benötigt, wie der Pfad zur ausführbaren Datei, die \emph{Endpoint}-Konfiguration für WCF, das Arbeitsverzeichnis etc. \texttt{Horde3DApplication} kennt diese Daten und die Methode \texttt{Start} startet eine neue Serverinstanz. Sobald der Server läuft, dient die Klasse als Fassade für den Service \emph{Proxy}. Zum Beenden des Servers muss die Methode \texttt{ShutDown} aufgerufen werden.

\subsection{Umsetzung des DLL-Replacements und des Profilings}
Der gewählte DLL-\emph{Replacement}-Mechanismus macht die Einführung von \emph{Proxy}-Funktionen erforderlich. Wenn die Anwendung eine \Horde-Funktion aufruft, so wird nicht sofort der Code der originalen \Horde\ DLL ausgeführt, sondern eine \emph{Proxy}-Funktion. Diese ruft die ursprüngliche Funktion auf, führt aber auch noch zusätzlichen Code aus. Dieser Code hängt jedoch davon ab, ob der Server gerade die \Horde-Funktionsaufrufe für die Profiling-Funktion protokolliert. 

Um mit den unterschiedlichen Codepfaden zurechtzukommen, wurden die in Abbildung~\ref{fig:proxyDesign} gezeigte Klassenstruktur entworfen. \texttt{Horde3DProxyBase} ist eine abstrakte Basisklasse, die für jede \Horde-Funktion einen Funktionszeiger sowie eine gleichnamige, abstrakte Methode mit gleichen Rückgabe- und Parametertypen wie die \Horde-Funktion besitzt. Aus Gründen der Übersichtlichkeit sind im Klassendiagramm~\ref{fig:proxyDesign} nur der Funktionszeiger und die \emph{Proxy}-Funktion für \texttt{Horde3D::getVersionString} eingezeichnet.

Die beiden Klassen \texttt{Horde3DNoProfilingProxy} und \texttt{Horde3DProfilingProxy} spezialisieren \texttt{Horde3DProxyBase}. Alle Funktionszeiger der Basisklasse werden geerbt und durch die ebenfalls geerbte \texttt{Initialize}-Methode initialisiert. Die beiden \emph{Proxy}-Klassen überschreiben die abstrakten \Horde-Methoden: Es wird jeweils die ursprüngliche \Horde-Funktion sowie die entsprechende Methode der statischen \texttt{Horde3DCall}-Klasse aufgerufen und gegebenenfalls die Profiling-Daten protokolliert. \texttt{Horde3DCall} besitzt für jede \Horde-Funktion eine statischen Methode und ein statisches \emph{Event}, welche jeweils die an die Funktion über\-ge\-benen Parameter und deren Rückgabewert als Parameter erhalten. Wird eine \Horde-Methode der \texttt{Horde3DCall}-Klasse aufgerufen, so wird das entsprechende spezifische \emph{Event} sowie die beiden generischen \emph{Events} \texttt{Before-/AfterFunctionCalled}  ausgelöst, wobei letztere jeweils vor -- respektive nach -- dem Auslösen des speziellen Ereignisses ausgelöst werden. Objekte des Servers können sich an diesen \emph{Events} registrieren und werden somit informiert, wann und mit welchen Parameter- und Rückgabewerten eine \Horde-Funktion aufgerufen wurde.

Die \texttt{Horde3DProxyHandler}-Klasse verwaltet die zwei verschiedenen \emph{Proxies} und hält eine Referenz auf die originale \Horde\ DLL, mit der die Funktionszeiger auf die \Horde-Funktionen ermittelt werden können. Mit \texttt{Initialize} werden die beiden \emph{Proxy}-Klassen initialisiert und eine Instanz des \texttt{Horde3DNoProfilingProxy} als Wert der \texttt{CurrentProxy}-Assoziation gesetzt. Die Methode \texttt{EnableProfiling} (de)aktiviert den Profiling-Modus, indem die \texttt{CurrentProxy}-Assoziation auf den entsprechenden \emph{Proxy} gesetzt wird.

Die API von \Horde\ verwendet allerdings keine Klassen, sondern organisiert die Funktionen im Namensraum \texttt{Horde3D}. Die \emph{Replacement}-DLL benötigt daher neben dieser Klassenstruktur noch \emph{Proxy}-Funktionen für alle \Horde-Funktionen im Namensraum \texttt{Horde3D} und eine globale Instanz der \texttt{Horde3DProxyHandler}-Klasse. Die \emph{Proxy}-Funktionen können dann mit der \texttt{GetCurrentProxy}-Methode der \texttt{Horde3DProxyHandler}-Klasse auf den derzeitigen \emph{Proxy} zugreifen und die entsprechende \Horde-Methode des \emph{Proxies} aufrufen. Dieser Vorgang wird am Beispiel des Profiling-\emph{Proxies} für die \Horde-Funktion \texttt{getVersionString} in Abbildung~\ref{fig:proxySeq} gezeigt, wobei zusätzlich noch \texttt{FunctionCall}-Objekte für die Profiling-Funktionalität erzeugt werden.

Das beschriebene Design wurde gewählt, weil es eine klare Trennung zwischen den beiden verschiedenen \emph{Proxies} ermöglicht. Die Trennung wurde nötig, da der Profiling-\emph{Proxy} für jeden Funktionsaufruf einige zusätzliche Schritte durchführen und mehrere Objekte anlegen muss, was einen negativen Einfluss auf die Performance in CPU-limitierten Szenen hatte. Daher sollte der Profiling-Code, wenn er nicht benötigt wird, auch nicht ausgeführt werden. 

Es hätte zwei denkbare Alternativen zur umgesetzten Lösung gegeben:

\begin{itemize}
	\item Man hätte direkt in den \emph{Proxy}-Funktionen im \texttt{Horde3D}-Namensraum die Original-Funktionen aufrufen und den zusätzlichen Code ausführen können, wobei man per \texttt{if-then-else} den Profiling-Code ein- und ausgeschaltet hätte. Dadurch hätte man sich den Aufruf der \texttt{GetCurrentProxy}-Methode gespart -- der aber im Regelfall vom Compiler sowieso \emph{inline} kompiliert wird -- und den virtuellen \Horde-Methodenaufruf des \emph{Proxies} durch die Auswertung einer Bedingung ersetzt. Der Performancevorteil der \texttt{if-then-else}-Lösung, falls überhaupt messbar, wäre aber im Vergleich zur Aus\-führ\-ungs\-dauer der eigentlichen Funktionen so gering, dass statt dieser Lösung die im objekt-orientierten Sinne bessere Alternative gewählt wurde.
	
	\item Eine weitere Variante betrifft die \texttt{Horde3DCall}-Klasse. Diese bietet neben den beiden generischen \emph{Events}, die nur den Namen der aufgerufenen Funktion übergeben, ein spezielles Ereignis mit Ein- und Ausgabewerten für jede \Horde-Funktion. Dies erfordert viel Code, der durch die Beschränkung auf die generischen \emph{Events} vermieden werden könnte. Dann müsste man allerdings die Ein- und Ausgabewerte der aufgerufenen Funktionen als \texttt{Object}-\emph{Array} übergeben. Das führt aber bei jedem Funktionsaufruf zur Erzeugung vieler temporärer Objekte, erfordert \emph{Boxing} und \emph{Unboxing} für Parameter primitiver Datentypen und beim Zugriff auf das Parameter-\emph{Array} eine Überprüfung der \emph{Array}-Grenzen sowie des Parametertyps. Da diese Lösung unperformant, belastend für den \emph{Garbage Collector} und zudem nicht einmal typsicher ist, wurde die aufwändigere, aber elegantere Variante gewählt.
\end{itemize}

\subsection{Anhalten der Anwendung}
In der ersten Iteration der Design-Phase war nicht klar, wie das Anhalten der Anwendung technisch genau lösbar ist. Es wurde daher das \emph{Strategy Pattern} verwendet, um verschiedene Ansätze möglichst einfach ausprobieren und austauschen zu können. Abbildung~\ref{fig:suspendStrategyDesign} zeigt den relevanten Ausschnitt des Designmodells. Das Interface \texttt{ISuspendApplicationStrategy} stellt die beiden Funktionen \texttt{Suspend} und \texttt{Resume} bereit, nach deren Ausführung die Anwendung entweder angehalten ist oder weiterläuft. Bei der Implementierung zeigte sich, dass insgesamt drei verschiedene Strategien zum Anhalten der Anwendung benötigt werden: \texttt{StopTimeSuspendStrategy}, um der Anwendung ein Anhalten der Zeit vortäuschen zu können; \texttt{CursorSuspendStrategy}, um der Anwendung die Kontrolle über den Mauszeiger gezielt entziehen und wieder zurückgeben zu können; und \texttt{WndProcSuspendStrategy}, um das \emph{Window Procedure} der Anwendung ersetzen und damit Benutzereingaben über Maus und Tastatur abfangen zu können. Die Umsetzung dieser Strategien und ihre Probleme werden in Kapitel~\ref{suspendApp} genauer erläutert.

Um diese Objekte nicht einzeln verwalten zu müssen, wurde in einer späteren Iteration die Container-Klasse \texttt{SuspendApplicationStrategy} hinzugefügt, die ebenfalls vom \emph{Suspend}-Interface erbt. Einzige Aufgabe dieser Klasse ist es, beim Aufruf ihrer \texttt{Suspend}- und \texttt{Resume}-Methoden die entsprechenden Methoden aller Objekte im \texttt{Strategies}-\emph{Property} aufzurufen. In Kapitel~\ref{Ausblick} findet sich ein Vorschlag, wie man aufbauend auf dieser Instanz des \emph{Strategy Patterns} und der \texttt{SuspendApplicationStrategy}-Klasse eine weitere Strategie zum Anhalten der Anwendung integrieren könnte.

\subsection{Starten und Beenden des Servers}
Die Abbildungen~\ref{fig:startSeq} und~\ref{fig:DebuggerInitSeq} zeigen, was beim Starten des Servers nach Aufruf der \texttt{Start}-Methode der \texttt{Horde3DApplication}-Klasse geschieht. Zunächst muss die originale \Horde\ DLL im Anwendungsverzeichnis umbenannt werden. Dann werden die benötigten DLLs des \DevEnvs\ in das Anwendungsverzeichnis kopiert, einschließlich der modifizierten \Horde\ DLL mit den \emph{Proxy}-Funktionen. Anschließend wird die Konfigurationsdatei für den Server generiert, die ebenfalls in das Anwendungsverzeichnis kopiert wird. Dannach wird der Prozess gestartet. Da es in der modifizierten \Horde\ DLL eine globale \texttt{Horde3DProxyHandler}-Variable gibt, wird beim Starten der Anwendung und nach dem Laden der modifizierten DLL automatisch eine \emph{Proxy Handler}-Instanz erzeugt. Der Konstruktor ruft die \texttt{Initialize}-Methode auf, die wiederum zunächst den \texttt{Horde3DDebugger}-\emph{Singleton} initialisiert. Clientseitig wird sofort eine Instanz des \texttt{DebuggerServiceProxy} erzeugt und mit dem Verbindungsaufbau zum Server begonnen. Da es keine Möglichkeit gibt, vom Server über den Abschluss der Initialisierung informiert zu werden, wird einfach so lange ein Verbindungsaufbau versucht, bis der Serverprozess hochgefahren und initialisiert ist und die Verbindung erfolgreich aufgebaut werden konnte.

Auf der Serverseite werden Instanzen der beiden \Horde-\emph{Proxies} erzeugt und der Pro\-fil\-ing-Modus standardmäßig deaktiviert. Die Initialisierungsroutine des \texttt{Horde3DDebugger}-\emph{Single\-tons} liest zunächst die Konfigurationsdaten aus der \emph{Settings}-Datei ein und überprüft die \Horde-Version. Der gewählte DLL-\emph{Replacement}-Mechanismus macht es erforderlich, dass die Anwendung und der Server die gleiche Version von \Horde\ verwenden. Sollte das nicht der Fall sein, wird sich die Anwendung in vielen Fällen mit einer Windows-Fehler\-mel\-dung "`Prozedureinsprungspunkt "`\textit{ProzedurName}"' wurde in der DLL "`\Horde.dll"' nicht gefunden."' beenden, bevor der Server initialisiert wird. Es gibt aber auch Fälle, in denen Windows die fehlenden oder zusätzlichen Einsprungspunkte nicht entdeckt. Dann überprüft der Server anhand der \Horde-Versionskennung beider DLLs, ob unterschiedliche Versionen vorliegen. Sind die Versionen unterschiedlich, wird die Anwendung mit einer Fehlermeldung beendet.

Der \texttt{Horde3DDebugger}-\emph{Singleton} erzeugt neben der \texttt{DebuggerService}-Instanz noch zwei weitere Objekte: \texttt{Horde3DMessagesHandler} und \texttt{Horde3DStateWatcher}. Die Aufgabe des \texttt{Horde3DMessagesHandler}s ist es, nach jedem Funktionsaufruf eventuell neu generierten Meldungen abzufangen. Wurde eine oder mehrere Meldungen generiert, so werden die Daten ausgelesen, für jede neu generierte Nachricht ein \texttt{Horde3DMessage}-Objekt erzeugt und dieses per \emph{Callback} an den Client gesendet. 

Zu beachten ist hierbei die Phase der Initialisierung und Deinitialisierung des Servers. Der \texttt{Horde3DMessagesHandler} darf nur nach neuen Meldungen fragen, solange \Horde\ korrekt initialisiert ist. Wird beispielsweise \texttt{Horde3D::getVersionString} vor dem Aufruf von \texttt{Horde3D::init} aufgerufen, würde ohne korrekte \Horde-Initialisierung bereits nach dem Aufruf von \texttt{Horde3D::getVersionString} nach neuen Nachrichten gefragt. Auch nach dem Aufruf von \texttt{Horde3D::release} würde nach neuen Meldungen gefragt werden; zu diesem Zeitpunkt ist \Horde\ allerdings bereits vollständig deinitialisiert. In beiden Fällen könnte es zu einem Absturz des Programms kommen.

Es ist allerdings kein Problem, wenn bereits Meldungen erzeugt werden, bevor der Client die Verbindung zum Server aufgebaut hat. Alle \emph{Callback}-Aufrufe werden abgefangen und erst ausgeführt, wenn die Verbindung steht.

Die \texttt{Horde3DStateWatcher}-Klasse hat derzeit nur die Aufgabe, unerwünschtes \emph{Reverse-Engineering} zu unterbinden. Die Klasse könnte aber in Zukunft erweitert werden, um beispielsweise die Kamera, mit der die Szene gezeichnet wurde, zu protokollieren. Das könnte in Szenen mit mehreren Kameras und mehreren Aufrufen von \texttt{Horde3D::render} wichtig sein. Momentan überprüft die Klasse allerdings nur, ob vor dem Aufruf von \texttt{Horde3D::render} die \Horde-Funktion \texttt{checkExtension} mit dem Parameter \texttt{AllowDebugging} aufgerufen wurde. Ist dies nicht der Fall, so wird beim Versuch die Szene zu zeichnen eine Fehlermeldung angezeigt und der Server beendet.

Das Beenden des Servers ist im wesentlichen eine Umkehr des Startprozesses. Die \texttt{ShutDown}-Methode der \texttt{Horde3DApplication}-Klasse schließt zunächst die Verbindung zum Server und beendet den Prozess durch Schließen des Hauptfensters. Falls der Prozess nach einem kurzen \emph{Timeout} von wenigen Sekunden nicht beendet wurde, wird er zwangsweise terminiert. Anschießend wird der ursprüngliche Zustand des Anwendungsverzeichnis wiederhergestellt. Die in das Verzeichnis kopierten DLLs des \DevEnvs\ werden gelöscht und auch die erstellte Konfigurationsdatei wird entfernt. Zum Schluss wird der umbenannten, originalen \Horde\ DLL wieder ihr ursprünglicher Name gegeben.

\subsection{Aktualisieren von Ressourcen-Daten}
Das Sequenzdiagramm~\ref{fig:UpdateResourceSeq} stellt das Vorgehen für die Aktualisierung von geänderten Ressourcen dar. Der Vorgang wird über die \texttt{Horde3DApplication}-Klasse angestoßen, da nur diese Klasse die \texttt{UpdateResource}-Operation des Servers aufrufen kann. Der Server führt die interne \texttt{UpdateHorde3D}-Methode der übergebenen \texttt{EditableResource} aus. Diese Methode ist virtuell und kann somit von den Subklassen überschrieben werden. Das Sequenzdiagramm zeigt die Funktionsweise der Stand\-ard\-implementierung. Zunächst wird überprüft, ob die Ressource, die \Horde\ gerade unter dem gleichen \texttt{ResHandle} kennt, den gleichen Typ und gleichen Namen hat. Implizit wird damit auch überprüft, ob überhaupt noch eine Ressource mit diesem \texttt{ResHandle} existiert. Dies ist notwendig, weil es das \DevEnv\ erlaubt, die Anwendung nach dem Einfrieren der Szene und nach dem Auslesen der bekannten Ressourcen weiter auszuführen. Der Benutzer könnte nun eine Ressource bearbeitet haben und diese an die \texttt{UpdateResource}-Operation des Servers übergeben. Zwischenzeitlich könnte die Anwendung die Ressource aber gelöscht und ihren \texttt{ResHandle} neu vergeben haben. Durch die Überprüfung des Ressourcennamens und -typs soll verhindert werden, dass die übergebene Ressource eine eventuell neu hinzugefügte Ressource überschreibt. Ansonsten würde die derzeit geladene Ressource durch eine eventuell völlig andere ersetzt. Bei unterschiedlichen Typen würde \Horde\ eine Fehlermeldung erzeugen, da die übergebenen Ressourcen-Daten dann nicht korrekt interpretiert werden können.

Ist die Überprüfung jedoch erfolgreich, werden die derzeit geladenen Ressourcen-Daten gelöscht. Die Ressource selbst bleibt aber erhalten, insbesondere ändert sich ihr \texttt{ResHandle} nicht. Nun können die Daten aus der übergebenen \texttt{EditableResource} in ein \texttt{byte}-\emph{Array} kopiert und an \Horde\ übergeben werden. Anschließend werden alle zur Zeit nicht geladenen aber bekannten Ressourcen geladen. Das ist erforderlich, weil die aktualisierte Ressource auf neue, noch nicht geladene Ressourcen verweisen könnte. Bevor die Szene mit der aktualisierten Ressource gezeichnet werden kann, müssen diese Abhängigkeiten geladen werden.

Wie bereits erwähnt ist die \texttt{UpdateHorde3D}-Methode der \texttt{EditableResource}-Klasse virtuell. Werden nämlich Shader- oder Material-Ressourcen aktualisiert, müssen noch einige zusätzliche Schritte ausgeführt werden. \Horde\ erlaubt das Klonen von Materials, das heißt, die Material-Ressource wird kopiert und der Kopie ein neuer \texttt{ResHandle} zugewiesen. Dadurch können zum Beispiel die \emph{Uniform}-Parameter des Materials für verschiedene Objekte unterschiedlich gesetzt werden. Allerdings werden die Kopien nicht aktualisiert, wenn das Original-Material aktualisiert wird. Übergibt man also eine \texttt{MaterialResource} an \texttt{UpdateResource}, so müssen alle Kopien des Materials gesucht und aktualisiert werden. Die Kopien sind an ihrem Namen erkennbar: hieß das Original-Material \texttt{Material1.material.xml}, dann heißen die Klone \texttt{Material1.material.xml|X}, wobei $X$ der \texttt{ResHandle} der Kopie ist.

Wird eine \texttt{ShaderResource} an \texttt{UpdateResource} übergeben, müssen ebenfalls noch weitere Ressourcen aktualisiert werden. Der GLSL-Code des Shaders wird von \Horde\ in zusätzlichen Code-Ressourcen gespeichert. Wird ein Shader aktualisiert, werden allerdings die Code-Ressourcen nicht automatisch neu geladen. Dies muss manuell geschehen. Dazu werden die abhängigen Code-Ressourcen über den Namen ermittelt, der als Präfix den Namen der zugehörigen Shader-Ressource enthält. Allerdings kann diese Sonderbehandlung der Shader-Ressourcen für zukünftigen \Horde-Versionen entfallen. Alle Versionen nach \Horde\ 1.0.0 Beta 3 aktualisieren automatisch auch alle abhängigen Code-Ressourcen.