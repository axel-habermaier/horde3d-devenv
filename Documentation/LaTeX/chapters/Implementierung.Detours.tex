\section{Anhalten der Anwendung}\label{suspendApp}
Das \DevEnv\ verwendet drei verschiedene Implementierungen des \texttt{ISuspendApplicationStrategy}-Interfaces zum Anhalten der Anwendung. Eine Strategie täuscht dem Prozess vor, dass keine Zeit mehr vergeht. Eine andere leitet alle Tastatur- und Mauseingaben des Benutzers an eine andere Funktion um. Die dritte Klasse zum Fangen und Freilassen des Mauszeigers kam erst nach der zweiten Iteration der Design-Phase hinzu. Dank der Verwendung des \emph{Strategy Patterns} musste jedoch nur eine Zeile Code im Konstruktor der \texttt{SuspendApplicationStrategy}-Klasse hinzugefügt werden, um die dritte Strategie einzubinden.

Die ursprüngliche Idee war, den Prozess der Anwendung wirklich anzuhalten. Dazu gibt es die Funktionen \texttt{SuspendThread} und \texttt{ResumeThread} der Win32-API. Mit Hilfe dieser Funktionen kann ein Thread pausiert und wieder fortgesetzt werden. Ruft man diese Funktionen für alle Threads eines Prozesses auf, so wird der komplette Prozess eingefroren und wieder fortgesetzt. Dieses Verfahren ist jedoch nicht problemlos anwendbar, da Teile des Prozesses noch weiterlaufen sollten; so sollte WCF in der Lage sein, Anfragen vom Client zu bearbeiten und \emph{Callbacks} auszulösen. Um das zu gewährleisten, darf der Thread, in dem WCF läuft, nicht angehalten werden. Die Win32-Funktionen arbeiten aber auf nativen Threads, während WCF in einem \emph{managed} Thread läuft. Es kann aber passieren, dass die CLR mehrere \emph{managed} Threads im gleichen nativen Thread laufen lässt. Noch problematischer wird es, wenn die \Horde-Anwendung ebenfalls in .NET geschrieben wurde oder mehrere \emph{AppDomains}\footnote{Eine .NET-\emph{AppDomain} kann man sich als einen .NET-Prozess vorstellen. Es kann in einem nativen Prozess mehrere \emph{AppDomains} geben. Das Betriebssystem kennt das Konzept der \emph{AppDomains} nicht.} im Prozess laufen. Es ist also schwierig genau festzustellen, welche Threads angehalten werden dürfen. Des Weiteren kommt noch hinzu, dass es verschiedene Versionen der \texttt{Suspend-/ResumeThread}-Funktionen für native 32 Bit Prozesse, 32 Bit Prozesse unter einem 64 Bit Betriebssystem und 64 Bit Prozesse gibt.

Derzeit ist für das richtige Anhalten des Prozesses keine \texttt{ISuspendApplicationStrategy}-Implementierung vorhanden. In vielen Fällen sind die drei im folgenden vorgestellten Strategien ausreichend. Es gibt aber auch Fälle, in denen ein richtiges Anhalten des Prozesses notwendig wäre. Im folgenden Abschnitt wird auf diese Problematik näher eingegangen.

\subsection{Anhalten der Zeit}\label{stoptime}
Um den Prozess nicht wirklich anhalten zu müssen, wurde eine Idee aus NVIDIAs PerfHUD übernommen: Das Anhalten der Zeit. Im Benutzerhandbuch gibt es einen Hinweis darauf, wie NVIDIA dieses Problem löst: 

\begin{quote}"`PerfHUD “freezes” your application by returning the same value every time your application asks for the current time."' \cite[S. 11]{perfhud}\end{quote}

Das ist auch die Vorgehensweise des \DevEnvs. Die meisten Anwendungen verwenden die hochauflösende \emph{Timer}-Funktion \texttt{QueryPerformanceCounter}, um die vergangene Zeit zu messen. Jeder Aufruf dieser Funktion wird an eine Funktion des Servers umgeleitet. Dort wird der wirkliche \emph{Timer} aufgerufen und der Rückgabewert aufgezeichnet. Ist die Anwendung angehalten, wird immer der Zeitwert zum Zeitpunkt des Anhaltens der Anwendung zurückgeliefert; die Anwendung meint, es sei seit dem letzten Frame keine Zeit vergangen. Dadurch ist die Zeit angehalten und die Anwendung pausiert. Wird die Anwendung wieder fortgesetzt, so wird wieder der richtige Zeitwert geliefert, abzüglich der Zeitdauer, während der die Anwendung pausiert war.

\begin{figure}[ht]
\centering
%trim=l b r t  	This option will crop the imported image by l from the left, b from the bottom, r from the right, and t  from the top. Where l, b, r and t are lengths. 
\includegraphics[trim = 5mm 270mm 60mm 5mm, clip, scale=0.7]{images/Detours.pdf}
\caption{Kontrollfluss bei einem abgefangenen Funktionsaufruf}\label{fig:detours}
\end{figure}

Technisch wird das Umleiten des Funktionsaufrufs durch Microsofts Detours Express Bibliothek gelöst. Die Bibliothek kann in einer Anwendung verwendet werden, um einen Aufruf einer beliebigen, nativen Funktionen (\emph{Target Function}) abzufangen und auf eine beliebige selbst definierte Funktionen (\emph{Detour Function}) umzuleiten. Zur Laufzeit schreibt Detours das Abbild des in den Prozess geladenen Binärcodes der \emph{Target Function} um. Abbildung~\ref{fig:detours} zeigt den Kontrollfluss beim abgefangenen Aufruf der \emph{Target Function}. Die ersten Instruktionen der \emph{Target Function} werden durch einen Sprung zur \emph{Detour Function} ersetzt. Es wird also als erstes die \emph{Detour Function} ausgeführt. Dort kann beliebiger Code abgearbeitet werden. Detours erzeugt außerdem eine \emph{Trampoline Function}, welche die ersetzen Instruktionen der \emph{Target Function} enthält und anschließend zur \emph{Target Function} zurückspringt. Die \emph{Detour Function} kann die \emph{Trampoline Function} aufrufen, um die \emph{Target Function} auszuführen. Verlässt der Kontrollfluss die \emph{Target Function}, ist wieder die \emph{Detour Function} aktiv und kann weiterhin beliebigen Code ausführen. Schließlich kehrt der Kontrollfluss zur aufrufenden Funktion (\emph{Source Function}) zurück.

Das Anhalten der Zeit hat einige wichtige Konsequenzen: Zum einen funktioniert die Vorgehensweise gar nicht, wenn die Anwendung nicht \texttt{QueryPerformanceCounter} zum Messen der Zeit verwendet. Da es aber keine anderen hochauflösenden Zeitmesser für Windows gibt, wird dies nicht oft der Fall sein. Zum anderen kommt es zu Problemen, wenn die Anwendung nicht so schnell arbeitet wie sie kann, sondern auf eine gewisse Zahl an Updates pro Sekunde festgelegt ist. Falls die Anwendung beispielsweise maximal 60 mal pro Sekunde ein Update ausführt, aber scheinbar seit dem letzten Frame keine Zeit vergangen ist, wird sie einfach gar nichts mehr tun; sie sollte aber wenigstens noch \texttt{Horde3D::render} aufrufen. Gegebenenfalls muss zur Verwendung des \DevEnvs\ die Frameraten-Limitierung abgeschaltet werden. Da beim Starten der Anwendung Kommandozeilenparameter übergeben werden können, kann die Abschaltung der Limitierung prinzipiell auch ohne eine Änderung der Anwendung erfolgen, falls die Anwendung per Kommandozeile entsprechend konfigurierbar ist.

Das Vorgehen funktioniert auch nicht, wenn für zeitabhängige Berechnungen nicht die vergangene Zeit ${\Delta}t$ sondern die aktuellen \emph{Frames Per Second} (FPS) verwendet werden. Da FPS $= 1 / {\Delta}t$ wird die FPS-Berechnung für ${\Delta}t = 0$ entweder nicht ausgeführt, oder sie liefert keinen vernünftigen Wert zurück.

Die Methode hat auch keinen Erfolg, wenn die Anwendung oder Teile der Anwendung zeitunabhängig arbeiten. Denkbar wäre zum Beispiel eine Client-Server-Anwendung, in der der Server kontinuierlich neue Positionen der Objekte berechnet und an den Client schickt. Der Client empfängt die Nachrichten des Servers, baut die Szene entsprechend um und zeichnet sie neu. Für den Benutzer scheint die Anwendung weiterhin zu laufen, obwohl der Client eigentlich angehalten ist und für ihn keine Zeit mehr vergeht.

All diese Probleme würden nicht auftauchen, wenn der Prozess der Anwendung wirklich angehalten werden würde, wie oben beschrieben. Es wurde dennoch aus zwei Gründen nur die Zeit-Methode umgesetzt: Erstens ist wie beschrieben beim Anhalten des Prozesses nicht klar, welche Threads angehalten werden dürfen, wohingegen die Implementierung der Zeit-Methode einfach ist. Zweitens wird die Zeit-Methode in jedem Fall benötigt. Hält man die Threads der Anwendung an, so laufen diese zwar nicht weiter, die Zeit aber schon. Setzt man nun die Threads fort, so können seit dem letzten Frame mehrere Sekunden oder Minuten vergangen sein. Die Physik- und Animationssysteme rechnen dann mit einem viel zu großen ${\Delta}t$ von mehreren Sekunden oder Minuten und können eventuell keinen stabilen Zustand mehr erreichen.

\subsection{Ersetzen des Window Procedures}
Die Win32-API verwendet Nachrichten, um mit einem Anwendungsprozess zu kommunizieren. Mit den Nachrichten kann die Anwendung über alle wichtigen Ereignisse informiert werden: Mausklicks, Tastatureingaben, Mausbewegungen, Schließen der Anwendung, Verschieben des Anwendungsfensters, Ablaufen eines \emph{Timers}, und so weiter. Alle Nachrichten an einen Prozess beziehungsweise an ein Fenster werden an eine ausgewiesene Funktion, das \emph{Window Procedure} (\emph{WndProc}), geschickt. Dort wird als Reaktion auf spezielle Nachrichten anwendungsspezifischer Code ausgeführt.

Das \DevEnv\ muss auf zwei Arten mit dem \emph{Window Procedure} der Anwendung interagieren: Einerseits muss es Nachrichten abfangen, die für den Server eine Bedeutung haben. Drückt der Benutzer beispielsweise die Taste F7, so soll der Server die Anwendung anhalten. Auf der anderen Seite darf das \emph{Window Procedure} der Anwendung keine Benutzereingaben mehr erhalten, wenn die Anwendung angehalten ist. Es soll aber dennoch möglich sein, das Anwendungsfenster zu verschieben oder zu schließen. 

Bei der Initialisierung des Servers wird mit der Win32-Funktion \texttt{SetWindowsHookEx} ein prozessweiter \emph{Hook} aktiviert, der alle Nachrichten an das \emph{WndProc} der Anwendung abfängt. Innerhalb des \emph{Hooks} wird überprüft, ob für den Server eine relevante Nachricht -- also zum Beispiel \texttt{KeyDown} für die Taste F7 -- geschickt wurde. In diesem Fall reagiert der Server entsprechend. Anschließend wird die Nachricht an das \emph{WndProc} weitergeleitet.

Mit der Funktion \texttt{SetWindowLongPtr} kann der \emph{WndProc}-Zeiger eines Fensters auf eine beliebige benutzerdefinierte Funktion gesetzt werden. Der Server ersetzt das \emph{Window Procedure} des Anwendungsfensters, wenn die Anwendung angehalten wird. Das \emph{WndProc} des Servers ignoriert alle eingehenden Nachrichten über Maus- und Tastatureingaben und behandelt nur Fenster-Nachrichten wie Verschieben oder Schließen. Beim Fortsetzen der Anwendung wird der Zeiger wieder auf das ursprüngliche \emph{WndProc} gesetzt.

\subsection{Freigabe des Mauszeigers}
Viele Anwendungen beschränken den Mauszeiger auf ihre Fenstergröße und verstecken ihn. Beim Testen des \DevEnvs\ mit den Beispielapplikationen des \Horde-SDKs zeigten sich verschiedene Probleme mit dieser exklusiven Benutzung der Maus. Der Server fängt daher -- wiederum mit der Detours Express Bibliothek von Microsoft -- alle Aufrufe der Win32-Funktionen \texttt{ShowCursor}, \texttt{ClipCursor} und \texttt{SetCursorPos} ab. Aufrufe dieser Funktionen werden protokolliert und anschließend die ursprünglichen Funktionen aufgerufen. Dadurch kann der Mauszeiger beim Anhalten der Anwendung freigegeben werden und beim Fortsetzen der Anwendung der von der Anwendung gewünschte Zustand wiederhergestellt werden.