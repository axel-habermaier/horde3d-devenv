\section{Konklusion}
In der Design-Phase wurden viele generische Konzepte verwendet, um flexibel auf mögliche Änderungen von \Horde\ oder eventuell auftauchende Probleme in der Implementierungs-Phase reagieren zu können. Aufgrund der detaillierten Analyse der Anforderungen und dem Aufbau von \Horde\ konnte ein Systemdesign erstellt werden, das bei der Implementierung nur wenige Probleme verursachte. Die notwendigen Änderungen am Design beschränkten sich jedoch immer auf einzelne Klassen; die grundlegende Architektur blieb bestehen. Eine größere Änderung ergab sich lediglich durch die Einführung der Client-Server-\emph{Callbacks}. 

Im Rahmen dieser Bachelorarbeit wurde aber nicht das komplette Design implementiert. So gibt es gerade bei den \Horde-Klassen einige Attribute und Assoziationen, die zwar im Designmodell vorhanden sind, für die Umsetzung der Systemanforderungen aber nicht erforderlich waren. Sie wurden dennoch in das Konzept- und Designmodell aufgenommen, um die Modelle zu vervollständigen. Im Code können diese bei Bedarf einfach hinzugefügt werden.

Bei der Entwicklung des \DevEnvs\ wurde auch deutlich, dass der verwendete DLL-\emph{Replacement}-Mechanismus sowie die Einführung der \texttt{Horde3DCall}-Klasse richtige Entscheidungen waren. Insbesondere die beiden Klassen \texttt{Horde3DMessagesHandler} und \texttt{Horde3DStateWatcher} zeigten, warum das Auslösen von generischen als auch spezifischen Ereignissen mit den genauen Aufrufsparametern und Rückgabewerten nach einem \Horde-Funktionsaufruf sinnvoll ist. Diese Informationen sind für unterschiedlichste Aktionen nützlich; so wurde beim Entwurf dieses Verfahrens nicht an die Verwendung eines \emph{Reverse-Engineering}-Schutzes gedacht. Sowohl die \texttt{Horde3DStateWatcher}-Klasse als auch die Anforderung vor dem Schutz vor unerwünschtem \emph{Reverse-Engineering} wurden erst in einer späteren Iteration ins \DevEnv\ aufgenommen und fügten sich nahtlos in das Systemdesign ein.

Die Entwicklung des GUI-Frameworks war zeitaufwändig und hätte vermieden werden kön\-nen, wenn das \DevEnv\ als Plugin für Visual Studio oder SharpDevelop entwickelt worden wäre. Aufgrund verschiedener Unzulänglichkeiten der Plugin-Infrastruktur der IDEs hat sich die Eigenentwicklung schließlich doch als die bessere Lösung herausgestellt, da sich während der Implementierung des Systems die Stärken des Frameworks zeigten und ein zügige und unkomplizierte Umsetzung des Designs ermöglichten. So ist der GUI- und Anwendungscode stets klar voneinander abgegrenzt und es ist einfach, neue Features durch Implementieren weiterer \texttt{Presenter}- und \texttt{View}-Klassen hinzuzufügen. Die Wiederverwendbarkeit und Erweiterbarkeit des Frameworks konnte bereits im Rahmen der Bachelorarbeit überprüft werden. So wurde zu einem späteren Zeitpunkt eine weitere \texttt{DockView}-Subklasse, \texttt{WpfDockView}, hinzugefügt, mit der Windows Presentation Foundation \texttt{UserControl}s in Windows Forms \texttt{DockView}s dargestellt werden können. Der Einsatz des Frameworks bei der Entwicklung des Code Generators, siehe Abschnitt~\ref{CodeGen}, bestätigte die Wiederverwendbarkeit der Bibliothek.