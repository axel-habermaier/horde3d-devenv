\section{Anbindung der Benutzeroberfläche an das System}
Die Anbindung der grafischen Benutzeroberfläche an den Anwendungscode wurde bislang nicht weiter betrachtet, ist jedoch ein komplexes Problem. Für das \DevEnv\ wurde eine eigene Bibliothek entwickelt, die die GUI-Anbindung an das System kapselt und einige Grundfunktionalitäten bereitstellt. Dabei standen die Wiederverwendbarkeit der Bibliothek sowie eine saubere Trennung zwischen GUI- und Anwendungscode im Vordergrund. 

\subsection{Alternativen zur Eigenentwicklung eines GUI-Frameworks}
Bevor mit der Entwicklung eines eigenen GUI-Frameworks begonnen wurde, wurden zwei alternative Ansätze in Betracht gezogen: Die Integration des Clients in Visual Studio oder in SharpDevelop\footnote{\url{http://www.icsharpcode.net/OpenSource/SD}} als Plugin. Beide Tools haben eine ausgereifte, mächtige und bewährte Plugin-Architektur und bieten viele Schnittstellen zu Subsystemen -- wie einen Texteditor mit \emph{Syntaxhighlighting}, eine Konsole für Textausgabe, ein \emph{Undo}/\emph{Redo}-Framework, ein Framework zum automatischen Speichern geänderter Dateien, etc. --, die das \DevEnv\ ebenfalls benötigt. Es bestand also ein großes Potential, bereits vorhandene und erwiesenermaßen gut funktionierende Lösungen wiederzuverwenden. Dennoch wurde auf diesen Vorteil verzichtet, da die Nachteile überwogen. Visual Studio ist ein extrem komplexes und im Kern auch sehr altes System, das zu weiten Teilen noch in \C++ und COM implementiert ist. Plugins können zwar in \Csharp/.NET entwickelt werden, allerdings sind die Interfaces, die Visual Studio bereitstellt, aufgrund ihres Alters überladen, schwer verständlich und nicht mehr zeitgemäß. Außerdem muss ein Plugin nach jeder Änderung neu integriert werden, was die Entwicklung verzögert und ein schnelles Debuggen unmöglich macht. Ein weiteres Problem ist, dass nicht jeder potenzielle Benutzer des \DevEnvs\ eine Visual Studio Lizenz besitzt; die kostenlosen Express-Versionen unterstützen leider keine Plugins. Die eigenständig lauffähige Visual Studio Shell würde diese Probleme zwar lösen, wäre aber aufgrund ihrer Größe (ca. 150 MByte) und Komplexität eine sehr belastende Abhängigkeit für das \DevEnv.

SharpDevelop hingegen wurde von Anfang an komplett in \Csharp\ entwickelt und ist Open Source. Die Einbindung von Plugins gestaltet sich angenehmer als unter Visual Studio und es gibt moderne objekt-orientierte APIs für den Zugriff auf die Standardkomponenten der Entwicklungsumgebung. Leider ist die Entwicklung von Plugins für SharpDevelop sehr schlecht dokumentiert. Es gibt zwar einführende Erläuterungen, aber eine prototypische Implementierung des \DevEnvs\ zeigte schnell, dass bei komplexeren Fragen und Problemen oft keine Hilfestellung in der Dokumentation, im Internet oder im inzwischen veralteten Buch \cite{sharpdevelop} existiert. Da die IDE Open Source ist, konnte die Antwort zwar immer durch Durchsehen des Quellcodes gefunden werden, dies nahm aber sehr viel Zeit in Anspruch. Visual Studio hingegen ist teilweise deutlich besser dokumentiert. Aber auch hier gibt es noch einige Defizite, insbesondere bei der Erweiterung der Standard-Projektverwaltung mit dem \emph{Visual Studio Managed Package Framework for Projects}\footnote{\url{http://www.codeplex.com/mpfproj}}.

\subsection{Architektur des GUI-Frameworks}\label{sec:aufbau}
Um eine klare Trennung zwischen GUI- und Anwendungscode zu erreichen, ist das GUI-Framework eine Instanz des \emph{Model-View-Presenter Patterns}. Es wurde außerdem von Anfang an auf die Entwicklung einer Visual Studio-ähnlichen Oberfläche ausgelegt, kann aber prinzipiell auch für andere UI-Designs verwendet werden. 

Abbildung~\ref{fig:guiClass} zeigt das Designklassen-Diagramm des GUI-Frameworks. Die Verwendung des \emph{Model-View-Presenter Patterns} wird durch die abstrakte Klasse \texttt{Presenter} und das Interface \texttt{IView} deutlich. Im GUI-Framework selbst kommen keine Modelle vor; diese sind anwendungsspezifisch und werden von den Applikationen, die das Framework verwenden, bereitgestellt.

Es gibt insgesamt vier Klassen, die das \texttt{IView}-Interface implementieren. Diese Klassen ergeben sich aus dem Design moderner GUI-Frameworks wie Windows Forms und der Windows Presentation Foundation. Dort gibt es zum einen \texttt{Form}-Klassen, welche ein eigenständiges Fenster repräsentieren. Diesen Fenstern können mehrere Instanzen von \texttt{UserControl}-Klassen untergeordnet sein, beispielsweise für Eingabefelder oder Schaltknöpfe. Um das Visual Studio-ähnliche Design zu realisieren, gibt es noch eine weitere spezielle Klasse, \texttt{DockContent}, deren Instanzen ebenfalls einer \texttt{Form} untergeordnet sein müssen. Dabei kann eine \texttt{DockContent}-Instanz sowohl ein eventuell verstecktes \emph{Dock Pane} an der Seite der Oberfläche, ein \emph{Floating Window} oder ein Dokument sein. Für all diese Klassen wird eine \texttt{IView}-Implementierung benötigt. \texttt{UserControlView} erbt von \texttt{UserControl} und \texttt{FormView} ist von \texttt{Form} abgeleitet, wobei hier zwischen modalen und nicht-modalen Fenstern unterschieden wird. \texttt{DockView} erbt von \texttt{DockContent} und fügt zwei Attribute hinzu, um den standardmäßigen \texttt{DockState} und die Menge der erlaubten \texttt{DockState}s festzulegen. \texttt{DocumentView} ist eine Subklasse von \texttt{DockView}, wobei hier der standardmäßige \texttt{DockState} und die Menge der erlaubten \texttt{DockState}s fest auf \texttt{Document} beschränkt sind.

Die abstrakte Klasse \texttt{Presenter} ist die Basisklasse für alle \emph{Presenter} im System. Instanzen von \texttt{Presenter} werden über einen Namen identifiziert; für einen gegebenen Namen kann es immer nur eine \texttt{Presenter}-Instanz geben. \texttt{Presenter} hat eine private Assoziation zu einem \texttt{IView}, auf die abgeleitete Klassen nur über die Funktion \texttt{UpdateView} zugreifen können. Damit wird zum einen die Kopplung zur \emph{View} verringert und zum anderen müssen in dieser Funktion noch einige implementierungsspezifische Details (Zugriff über korrekten Thread, kein Zugriff auf bereits gelöschte \emph{Views}, etc.) geregelt werden. Zu beachten ist, dass nur die abstrakte \texttt{Presenter}-Klasse ihre zugehörige \emph{View} kennt; insbesondere kennen die \texttt{IView}-Instanzen nicht ihre zugehörige \texttt{Presenter}-Instanzen. Dies wird durch das \texttt{Request}-Ereignis, das alle \texttt{IView}-Implementierungen besitzen, ermöglicht. Ein \emph{Presenter} registriert sich an den \texttt{Request}-Ereignissen seiner \emph{View} und kann darüber über Eingaben und Aktionen des Benutzers informiert werden.

Die GUI-\emph{Controls} bilden eine Hierarchie aus \texttt{Form}-, \texttt{DockContent}- und \texttt{UserControl}-In\-stan\-zen. Diese Hierarchie müssen auch die \emph{Presenter} widerspiegeln. Aus diesem Grund kann ein \texttt{Presenter} einen \texttt{Parent} und beliebig viele \texttt{Children} haben, die über die Funktionen \texttt{Add-/RemoveChildPresenter} hinzugefügt und wieder entfernt werden können. \texttt{Presenter} hat außerdem abstrakte Methoden für die Initialisierung und Deinitialisierung. Abgeleitete \texttt{Presenter}-Klassen müssen diese Methoden mit einer speziellen Implementierung über\-schrei\-ben. Die \emph{Presenter}- und \emph{View}-Hierarchien  sind eine Instanz des \emph{Composite Patterns}.

Da eine \emph{Undo}/\emph{Redo}-Funktionalität benötigt wird, werden vom Benutzer ausgeführte Aktionen gemäß des \emph{Command Patterns} durch Objekte gekapselt, die von der abstrakten Klasse \texttt{Command} erben müssen. Ein \texttt{Command} hat Funktionen zum Ausführen der Aktion (\texttt{Execute}), sowie zum Rückgängigmachen (\texttt{Undo}) und Wiederholen (\texttt{Redo}); wobei \texttt{Redo} standardmäßig einfach noch einmal \texttt{Execute} aufruft und \texttt{Execute} und \texttt{Undo} abstrakt sind. Es ist auch möglich, die \emph{Undo}/\emph{Redo}-Funktionalität für einen \texttt{Command} zu deaktivieren, indem die \texttt{CanUndo}- und \texttt{CanRedo}-Attribute auf \texttt{false} gesetzt werden. Instanzen von \texttt{Command} werden immer von einem \texttt{Presenter} erzeugt und jeder \texttt{Command} kennt seinen Erzeuger. Über diese Assoziation können alle \texttt{Command}-Objekte eines \texttt{Presenter}s beim Entfernen des \texttt{Presenter}s aus der GUI gelöscht werden, wodurch die Aktionen dieser \texttt{Command}s nicht mehr rückgängig gemacht werden können.

\texttt{Command}-Objekte werden vom \texttt{CommandDispatcher} verwaltet. Dessen \texttt{HandleCommand}-Me-thode ruft die \texttt{Execute}-Methode des übergebenen \texttt{Command}s auf und verwaltet intern eine \emph{Undo}-/\emph{Redo}-Liste von bereits ausgeführten Aktionen. Der \texttt{CommandDispatcher} kann über die Funktionen \texttt{Undo} und \texttt{Redo} angewiesen werden, eine Aktion rückgängig zu machen oder zu wiederholen. Dies ist allerdings nur möglich, wenn das \texttt{CanUndo}- respektive das \texttt{CanRedo}-Attribut des \texttt{CommandDispatcher}s auf \texttt{true} gesetzt ist. Ändert sich der Wert eines dieser Attribute wird ein entsprechendes Ereignis ausgelöst, ebenso nach dem Rückgängigmachen und Wiederholen einer Aktion.

Das \DevEnv\ stellt editierbare Ressourcen als \texttt{DocumentView}-Instanzen dar. Nach dem Ändern einer Ressource sollen die Änderungen gespeichert werden können. Außerdem soll das Framework einen visuellen Hinweis geben, falls ein Dokument geändert wurde, aber die Änderungen noch nicht gespeichert sind. Schließt der Benutzer ein geändertes und noch nicht gespeichertes Dokument, so soll das Framework den Benutzer fragen, ob die Änderungen gespeichert oder verworfen werden sollen. Diese Aufgaben übernimmt die \texttt{SaveableContentManager}-Klasse, an der \texttt{Presenter}, die das \texttt{ISaveableContentPresenter}-Interface implementieren, registriert und wieder entfernt werden können. Registrierte \texttt{ISaveableContentPresenter}-Instanzen können einzeln oder alle auf einmal gespeichert werden. Wird ein geänderter, aber noch nicht gespeicherter \texttt{Presenter} geschlossen, so wird der Benutzer gebeten, die Änderungen zu speichern oder zu verwerfen.

Das \texttt{ISaveableContentPresenter}-Interface stellt Methoden zum Laden und Speichern des zu persistierenden Objekts bereit. Auch der aktuelle \texttt{SaveState} wird dort verwaltet. Das Interface wird von der abstrakten Klasse \texttt{SaveableContentPresenter} implementiert, die die normale \texttt{Presenter}-Klasse erweitert.

Die \texttt{Shell}-Klasse ist schließlich das Hauptelement des Frameworks. In ihr laufen alle Vorgänge zusammen. \texttt{CommandDispatcher} und \texttt{SaveableContentManager} sind mit einer 1:1-Assoziation zur \texttt{Shell} verbunden und hätten somit auch direkt in die \texttt{Shell}-Klasse integriert werden können. Dies hätte jedoch zu einer niedrigen Kohäsion und damit zu einer Überladung der \texttt{Shell}-Klasse geführt, was durch die Verteilung der Zuständigkeiten vermieden wurde. Da der \texttt{SaveableContentManager} nur der \texttt{Shell} bekannt ist, ist die \texttt{Shell} hier eine Instanz des \emph{Facade Patterns}. Auch das \emph{Singleton Pattern} wird von der \texttt{Shell} verwendet: Mit dem \texttt{Current}-Attribut kann global auf die \texttt{Shell}-Instanz zugegriffen werden, wobei es nur eine \texttt{Shell}-Instanz pro \emph{AppDomain} geben darf. Dies ist konsistent mit dem Vorgehen der \texttt{Application}-Klasse der Windows Presentation Foundation.

Die Aufgabe der \texttt{Shell}-Klasse ist neben der Initialisierung der gesamten Oberfläche auch die Verwaltung aller \texttt{Presenter}-Instanzen. \texttt{Presenter} können hinzugefügt, wieder entfernt und Dokumente einzeln oder gemeinsam gespeichert oder geschlossen werden. Auch das Layout der \emph{Dock Panes} wird von der \texttt{Shell}-Klasse automatisch persistiert und beim Starten der Anwendung wiederhergestellt.

\input{chapters/Design.Models}