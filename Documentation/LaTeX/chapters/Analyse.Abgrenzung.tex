\section{Verwandte Softwaretools}\label{abgrenzung}
Neben dem \DevEnv\ gibt es eine Reihe weiterer Tools mit dem Ziel, die Entwicklung von 3D-Anwendungen zu vereinfachen und zu beschleunigen. Dabei unterscheiden sich die Tools nicht nur in ihrer Umsetzung, sondern vor allem auch darin, welches Problem sie zu lösen versuchen. 

Nachdem die erste Iteration der Analyse abgeschlossen war, wurden die gefundenen Anforderungen mit bereits vorhandenen Tools verglichen. Teilweise dienten Ideen anderer Tools als Grundlage für Erweiterungen und Ergänzungen der Anforderungen während der zweiten Iteration der Analyse-Phase. Es konnten aber auch Ideen für die Design- und Implementierungs-Phasen gewonnen werden.

Die folgenden Tools wurden eingehender betrachtet. Es wird kurz auf den Verwendungszweck, die Unterschiede zum \DevEnv\ und auf die für die weitere Entwicklung hilfreichen Ideen eingegangen.

\subsection{Horde3D Scene Editor}
Volker Wiendl entwickelte den Horde3D Scene Editor \cite{h3dscenewiki} zum Erstellen und Manipulieren von Szenen. Die erstellten Szenen können als \emph{Scene Graph Resource} gespeichert und von anderen \Horde-Anwendung geladen und angezeigt werden. Die Hauptaufgabe des Tools unterscheidet sich somit grundlegend von den Anforderungen an das \DevEnv. Es gibt jedoch auch Überschneidungen, da der Editor auch Unterstützung für die Entwicklung von Effekten bietet:

\begin{itemize}
	\item Ressourcen, die außerhalb des Editors verändert werden, werden sofort neu geladen und die Szene mit den geänderten Ressourcen gezeichnet. Das \DevEnv\ bemerkt externe Änderungen der Ressourcen-Dateien derzeit nicht.
	\item Es ist ein Designer zum Ändern von Materialeigenschaften integriert. Das \DevEnv\ bietet hierfür keinen Designer an, sondern erlaubt nur die direkte Änderung der XML-Datei des Materials. Allerdings bietet der Szenen-Editor keinen Designer für Shader an.
	\item Auch der Editor erlaubt das Anzeigen des Inhalts eines beliebigen \emph{Render Targets}. Jedoch wird der dargestellte Inhalt nicht automatisch aktualisiert, wenn sich die Szene ändert.
	\item Der Editor verwendet \Horde\ zum Darstellen der Szene. Allerdings läuft dabei nicht der Code der Anwendung mit, für die die Szene erstellt wird. Dies ist problematisch, wenn Shader-Effekte von Parametern abhängen, die vom Anwendungscode in jedem Frame neu gesetzt werden müssen. In \SheepMeUp\ betraf dies die Kraftfeld- und Schock\-wel\-len-Effekte, die von einem Zeitparameter abhingen. Da der Editor diesen Parameter nicht aktualisierte, wurden die Effekte innerhalb des Editors nicht korrekt dargestellt.
	\item Die Szene kann nicht eingefroren und in Ruhe betrachtet werden, was zum Beispiel das Entwickeln von kurzlebigen Partikeleffekten erschweren kann. Auch der Schockwellen-Effekt von \SheepMeUp\ wird nur etwa eine Sekunde lang angezeigt. Das Finetuning solcher Effekte wird durch das Einfrieren der Szene erleichtert.
	
	\item Der Szenen-Editor kann durch Plugins erweitert werden, wodurch prinzipiell auch der Anwendungscode im Editor mitlaufen könnte. Allerdings erfordert dies eine Anpassung der Anwendung an den Editor, was in vielen Fällen nicht erwünscht ist. Als Alternative gibt es die Game Engine der Universität Augsburg\footnote{\url{http://mm-werkstatt.informatik.uni-augsburg.de/projects/GameEngine/doku.php}}, die eng mit dem Szenen-Editor verknüpft ist und beispielsweise Plugins für Physik und Sound bietet. Um von diesen Plugins profitieren zu können, müsste die Anwendung neben \Horde\ aber auch die Game Engine verwenden. Beim \DevEnv\ hingegen sollen alle Features unabhängig von der Anwendung verwendbar sein; es kann mit jeder beliebigen \Horde-Anwendung -- auch mit dem Szenen-Editor und der Game Engine -- zusammenarbeiten, ohne Änderungen am Code nötig zu machen. Die \Horde-Anwendung wird dabei normal ausgeführt und bekommt von der Verwendung des \DevEnvs\ nichts mit.
	\item Der Szenen-Editor ist plattformunabhängig in \C++ und Qt implementiert. Das \DevEnv\ hingegen läuft nur unter Windows, da das .NET Framework 3.5 Service Pack 1 vorausgesetzt wird und einige Windows-spezifische Funktionen und Bibliotheken verwendet werden. Jedoch ist eine Implementierung in \Csharp\ und .NET im Allgemeinen weniger fehleranfällig, einfacher und schneller.
\end{itemize}

\subsection{PIX for Windows}

Microsofts DirectX SDK\footnote{\url{http://msdn.microsoft.com/en-us/directx/default.aspx}} enthält das Direct3D Debugging-Tool PIX for Windows. Die Hauptaufgabe von PIX ist das Auffinden von Problemen bei der Verwendung der Direct3D-API. %Abbildung~\ref{fig:pix} zeigt einen Screenshot aus einer Debugsession mit PIX. 
Es wird eine Historie aller Direct3D Funktionsaufrufe angezeigt, sowie wichtige Daten über alle allozierten Direct3D-Ressourcen wie \emph{Vertex Buffer}, \emph{Index Buffer}, Texturen oder \emph{Render Targets}. Man kann sich den Inhalt eines \emph{Render Targets} anzeigen und die Szene schrittweise -- also \emph{Render Call} für \emph{Render Call} -- zeichnen lassen. Besonders hilfreich ist die Möglichkeit, Vertex, Geometry und Pixel Shader zu debuggen. Dazu wählt man einfach ein Vertex, Polygon oder Pixel in der Szene aus. PIX zeigt dann den Source Code des Shaders an und ermöglicht ein zeilenweises Durchlaufen des Codes und Anzeigen der Variablenwerte, wie man es vom Visual Studio Debugger gewohnt ist. Mit entsprechender Unterstützung des Grafikkartentreibers können auch verschiedene Metriken -- wie Auslastung der \emph{Raster Operation Units}, der \emph{Texture Mapping Units} sowie der Shadereinheiten der Grafikkarte -- für einen Frame untersucht und entsprechende Performanceoptimierungen an der Direct3D-Anwendung vorgenommen werden.
	
%\begin{figure}[ht]
%\centering
%%trim=l b r t  	This option will crop the imported image by l from the left, b from the bottom, r from the right, and t  from the top. Where l, b, r and t are lengths. 
%\includegraphics[scale=0.38]{images/PIX.png}
%\caption{Debuggen von Direct3D Anwendungen mit Microsofts  PIX for Windows}\label{fig:pix}
%\end{figure}
%	
\Horde\ hat derzeit nur einen OpenGL Renderpfad und somit ist die Verwendung von PIX für \Horde-Anwendungen unmöglich. Die Ziele des \DevEnvs\ unterscheiden sich allerdings hauptsächlich im Abstraktionslevel von den Zielen des Microsoft Tools: Beide Tools erlauben die Betrachtung des Zustands einer Software, die eine entsprechende API verwendet. Bei PIX ist diese API Direct3D, beim \DevEnv\ ist es \Horde. Insbesondere stammt die Idee der Funktionsaufruf-Historie und -Performanceauswertung aus PIX.
	
\subsection{NVIDIA PerfHUD}
NVIDIA PerfHUD\footnote{\url{http://developer.nvidia.com/nvperfhud_home.html}} ist ebenfalls ein Tool zum Debuggen von Direct3D-Anwendungen. Allerdings ist der Fokus nicht der gleiche wie bei PIX, sondern die Tools ergänzen sich in ihren Möglichkeiten. So erlaubt PerfHUD ebenfalls ein schrittweises Zeichnen der Szene, unterstützt allerdings kein Shaderdebugging. Auch ist PerfHUD keine eigenständige Anwendung wie PIX, sondern läuft direkt in der zu debuggenden Anwendung mit. PerfHUDs Hauptaufgabe ist die Unterstützung der Performanceoptimierung und Auffinden von Flaschenhälsen in der Grafik-Pipeline. Alle Performancecounter der NVIDIA Grafikkarten können mit dem Tool ausgelesen werden. Dies ermöglicht es beispielsweise, für einen \emph{Draw Call} die Auslastung der Shader Einheiten der Grafikkarte, die CPU-Auslastung durch den Grafikkartentreiber usw. zu ermitteln und auszuwerten.

Im Vergleich zum \DevEnv\ gibt es fast keine Überschneidungen in der Funktionalität. Jedoch macht es die Funktionsweise von PerfHUD erforderlich, die Szene einzufrieren. Der User Guide \cite[S. 11]{perfhud} gibt einen Hinweis darauf, dass dies technisch über ein "`Anhalten der Zeit"' gelöst wurde. Das \DevEnv\ verwendet einen analogen Lösungsansatz. Des Weiteren wurde Nicolas Schulz von diesem Tool inspiriert, als er den Schutz vor unerwünschtem \emph{Reverse-Engineering} vorschlug. PerfHUD lässt sich nur mit Anwendungen verwenden, die beim Starten ein spezielles Direct3D-\emph{Device} auswählen. Wählt die Anwendung in \emph{Release Builds} das PerfHUD-\emph{Device} nicht aus, verweigert das Tool seinen Dienst. Damit können Konkurrenzfirmen nicht herausfinden, wie die Anwendung eine Szene berechnet und auf welche Performancecharakteristika die Anwendung optimiert wurde.

\subsection{NVIDIA FxComposer und AMD RenderMonkey Toolsuite}
NVIDIA FxComposer\footnote{\url{http://developer.nvidia.com/object/fx_composer_home.html}} und AMD RenderMonkey Toolsuite\footnote{\url{http://developer.amd.com/GPU/RENDERMONKEY/Pages/default.aspx}} sind Entwicklungsumgebungen für Shader und Materials. Sie bieten eine Vorschau der erstellten Effekte an und können diese in verschiedene Formate für OpenGL- und Direct3D-Anwendungen exportieren. Allerdings gibt es derzeit keinen Exporter für das \Horde-Shaderformat und GLSL wird von beiden Tools nicht direkt unterstützt.

Im Gegensatz zum \DevEnv\ ist jedoch keine direkte Integration mit der Anwendung vorgesehen; die erstellten Shader und Materials können also nicht sofort in der Anwendung betrachtet werden. 